<!DOCTYPE html><html lang="zh" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>经典算法背诵 | Nervld的小窝</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.woff2"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><meta name="page-config" content="{&quot;code_fold&quot;:null}"><script class="pjax-js">var config = {"root":"/","code_fold":15,"search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}};
var page_config = {
  code_fold: null
};
function updatePageConfig() {
  var newPageConfig = document.querySelector('meta[name="page-config"]');
  if (newPageConfig) {
    page_config = JSON.parse(newPageConfig.content);
  }
}
document.addEventListener('pjax:complete', function() { updatePageConfig(); });
updatePageConfig();</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('/img/mybg3.png');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer src="https://vercount.one/js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.vercount','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => {
 const script = document.createElement('script');
 script.src = 'https://vercount.one/js';
 document.head.appendChild(script);
});reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.vercount','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => {
 const script = document.createElement('script');
 script.src = 'https://vercount.one/js';
 document.head.appendChild(script);
});reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>经典算法背诵</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2025-12-16T16:13:09.955Z" id="date"> 2025-12-17</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2026-01-07T02:49:56.628Z" id="updated"> 2026-01-07</time></div></span><br><span>文章总字数: <div class="control">5.7k</div></span><br><span>预计阅读时间: <div class="control">28 分钟</div></span><br><span id="vercount_container_page_pv">页面浏览: <span class="control" id="vercount_value_page_pv">加载中...</span></span></div></div><hr><div id="post-content"><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123; <br>	<span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b); <br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>	<span class="hljs-keyword">return</span> a / gcd(a, b) * b;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="试除法判断是不是质数"><a href="#试除法判断是不是质数" class="headerlink" title="试除法判断是不是质数"></a>试除法判断是不是质数</h2><pre><code>稳定O(sqrt(n))
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	<span class="hljs-comment">// 这里不用sqrt(n)是因为这个开销大</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i &lt;= n/i; i++) &#123;<br>		<span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> is_prime[N] = &#123;<span class="hljs-literal">true</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span>(is_prime[i]) &#123;<br>			primes[cnt++] = i;<br>			<span class="hljs-comment">// i是素数，那么i的倍数也都是</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+i; j &lt;= n; j+=i) &#123;<br>				is_prime[j] = <span class="hljs-literal">false</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h3><pre><code>（解决重复标记合数，更快）
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> is_prime[N] = &#123;<span class="hljs-literal">true</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span>(is_prime[i]) primes[cnt++] = i;<br>		<span class="hljs-comment">// 从小到大遍历质数</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> idx=<span class="hljs-number">0</span> ;primes[idx] &lt;= n/i; idx++) &#123;<br>			is_prime[primes[idx] * i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 将质数的i倍都删掉</span><br>			<span class="hljs-keyword">if</span>( i % primes[idx] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// i一定有最小质因子primes[idx]</span><br>		&#125;<br>		<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h2><pre><code>n中最多只包含一个大于sqrt(n)的质因子
最好O(log(n)) ，最坏O(sqrt(n))
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-comment">// 这里不用sqrt(n)是因为这个开销大</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i &lt;= n/i; i++) &#123;<br>		<span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>) &#123;<br>				n /= i;<br>				s ++;<br>			&#125;<br>			cout &lt;&lt; <span class="hljs-string">&quot;质因子&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;次数为&quot;</span> &lt;&lt; s &lt;&lt; endl;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;质因子&quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;次数为1&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="求因数个数和数值和"><a href="#求因数个数和数值和" class="headerlink" title="求因数个数和数值和"></a>求因数个数和数值和</h2><p>一个数可以拆分为多个素数乘积，这些素数又可以选部分进行组合，每一个素数可以有0~k，即k+1种选择，总共就是他们相乘<br class='item-img' data-src='/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122090815698.png'><img src="/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122090815698.png"></p>
<h2 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法"></a>大数乘法</h2><p>【LeetCode43.字符串相乘 C++大数相乘 高精度乘法】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sK4y1t7o1/?share_source=copy_web&vd_source=14e185a63eba25c1a3930fb174c86816">https://www.bilibili.com/video/BV1sK4y1t7o1/?share_source=copy_web&amp;vd_source=14e185a63eba25c1a3930fb174c86816</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">big_mul</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> alen = a.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> blen = b.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> clen = alen + blen;<br>    <span class="hljs-comment">// 翻转AB</span><br>    <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">reverse</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(clen,<span class="hljs-number">0</span>)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;alen;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;blen;j++) &#123;<br>            c[i+j] += (a[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (b[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    string res;<br>    <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示低位给过来的进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;clen;i++) &#123;<br>        carry += c[i];<br>        res.<span class="hljs-built_in">push_back</span>((carry % <span class="hljs-number">10</span>)+<span class="hljs-string">&#x27;0&#x27;</span>);<br>        carry /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=res.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br>        <span class="hljs-keyword">if</span>(res[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            res.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>) res = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="快速幂运算"><a href="#快速幂运算" class="headerlink" title="快速幂运算"></a>快速幂运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> exp, <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (exp &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (exp % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            result = (result * base) % mod;  <span class="hljs-comment">// 如果指数是奇数，乘上当前的base</span><br>        &#125;<br>        base = (base * base) % mod;  <span class="hljs-comment">// base自乘</span><br>        exp /= <span class="hljs-number">2</span>;  <span class="hljs-comment">// 指数减半</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> exp)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (exp &gt; <span class="hljs-number">0</span>) &#123;<br>	    <span class="hljs-keyword">if</span> (exp % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//如果是奇数(二进制为1)就将当前底数乘到结果上</span><br>		    result = result * base;<br>	    &#125;<br>	    base = base * base;<br>	    exp /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-type">long</span> base, <span class="hljs-type">long</span> exp)</span> </span>&#123;<br>	<span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (exp &gt; <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">if</span> (exp % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>			<span class="hljs-comment">// 是奇数就可以先乘一个base上去</span><br>			res*=base;<br>		&#125;<br>		<span class="hljs-comment">// 否则就可以/2然后base**</span><br>		base*=base; <span class="hljs-comment">// 因为偶数必然变为奇数，肯定会乘到res上</span><br>		exp/<span class="hljs-number">2</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="GCD求最大公约数，最小公倍数"><a href="#GCD求最大公约数，最小公倍数" class="headerlink" title="GCD求最大公约数，最小公倍数"></a>GCD求最大公约数，最小公倍数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b,a%b) : a;<br>&#125;<br><br><span class="hljs-comment">// 辗转相除法求最大公约数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> temp = b;<br>        b = a % b;<br>        a = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-comment">// 最小公倍数是两数乘积除以最大公约数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (a / <span class="hljs-built_in">gcd</span>(a, b)) * b;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coins.size(); i++) &#123;      <span class="hljs-comment">// 先遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> amount; j &gt;= coins[i]; j++) &#123; <span class="hljs-comment">// 再遍历背包容量（倒序）</span><br>        dp[j] += dp[j - coins[i]];             <span class="hljs-comment">// 累加组合数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coins.size(); i++) &#123;      <span class="hljs-comment">// 先遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 再遍历背包容量（正序）</span><br>        dp[j] += dp[j - coins[i]];             <span class="hljs-comment">// 累加组合数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设原始物品：数量 cnt，体积 v，价值 w</span><br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (k &lt;= cnt) &#123;<br>	<span class="hljs-comment">// 拆出一个组合：k 个该物品</span><br>	new_v = k * v;<br>	new_w = k * w;<br>	<span class="hljs-comment">// 将 (new_v, new_w) 当作 0-1 背包物品加入列表</span><br>	items.push_back(&#123;new_v, new_w&#125;);<br>	cnt -= k;<br>	k *= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span>) &#123;<br>	<span class="hljs-comment">// 剩下的部分</span><br>	new_v = cnt * v;<br>	new_w = cnt * w;<br>	items.push_back(&#123;new_v, new_w&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="排列背包"><a href="#排列背包" class="headerlink" title="排列背包"></a>排列背包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= target; j++) &#123;          <span class="hljs-comment">// 先遍历背包容量</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;   <span class="hljs-comment">// 再遍历物品</span><br>		<span class="hljs-keyword">if</span> (j &gt;= nums[i]) dp[j] += dp[j - nums[i]]; <span class="hljs-comment">// 累加排列数</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构建next数组，这个next数组是表示从当前到开头的最长公共前后缀</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">buildNext</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = pattern.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(m, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; pattern[j] != pattern[i]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 要循环跳转到前一个的next值</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (pattern[i] == pattern[j]) &#123;<br>            j++; <span class="hljs-comment">// j的值还代表了最长匹配前后缀长度</span><br>        &#125;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br><br><span class="hljs-comment">// 构建nextval数组</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">buildNextVal</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = pattern.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextval</span><span class="hljs-params">(m, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; m) &#123;<br>        <span class="hljs-keyword">if</span> (pattern[i] == pattern[len]) &#123;<br>            len++;<br>            nextval[i] = len;<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>            len = nextval[len - <span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nextval[i] = <span class="hljs-number">0</span>;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nextval;<br>&#125;<br><br><span class="hljs-comment">// KMP搜索算法</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; text, <span class="hljs-type">const</span> string&amp; pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> m = pattern.<span class="hljs-built_in">length</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">buildNext</span>(pattern);<br>    vector&lt;<span class="hljs-type">int</span>&gt; positions; <span class="hljs-comment">// 存储匹配开始的位置</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 模式字符串的索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; pattern[j] != text[i]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pattern[j] == text[i]) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == m) &#123;<br>            positions.<span class="hljs-built_in">push_back</span>(i - m + <span class="hljs-number">1</span>); <span class="hljs-comment">// 匹配成功，记录位置</span><br>            j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 继续查找下一个匹配</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> positions;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>        sort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, temp);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] temp)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        sort(arr, left, mid, temp);<br>        sort(arr, mid + <span class="hljs-number">1</span>, right, temp);<br>        merge(arr, left, mid, right, temp);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] temp)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 合并两个有序数组</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) &#123;<br>                temp[k++] = arr[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp[k++] = arr[j++];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 复制剩余元素</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];<br>        <br>        <span class="hljs-comment">// 将临时数组复制回原数组</span><br>        <span class="hljs-keyword">for</span> (i = left, k = <span class="hljs-number">0</span>; i &lt;= right; i++, k++) &#123;<br>            arr[i] = temp[k];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        sort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[left];  <span class="hljs-comment">// 选择第一个元素作为基准</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left, j = right;<br>        <br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-comment">// 从右往左找第一个小于基准的值</span><br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;<br>            <span class="hljs-comment">// 从左往右找第一个大于基准的值</span><br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;<br>            swap(arr, i, j);<br>        &#125;<br>        swap(arr, i, left); <span class="hljs-comment">// i表示最后pivot的位置</span><br>        <br>        sort(arr, left, i - <span class="hljs-number">1</span>);<br>        sort(arr, i + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="快速选择算法quickSelect"><a href="#快速选择算法quickSelect" class="headerlink" title="快速选择算法quickSelect"></a>快速选择算法quickSelect</h1><pre><code>其实一般来说只需要O(nlogn)的优先队列算法就够用，实在过不了再用下面的O(n)算法
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-comment">// O(n)时间选择出排序后的第K个元素，如果倒过来请给第N-K+1个元素</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-type">int</span> partitionIdx = <span class="hljs-built_in">randomPartition</span>(nums, left, right);<br>        <span class="hljs-type">int</span> curth = partitionIdx - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(curth == k)&#123;<br>            <span class="hljs-keyword">return</span> nums[partitionIdx];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curth &gt; k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, left, partitionIdx<span class="hljs-number">-1</span>, k);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, partitionIdx+<span class="hljs-number">1</span>, right, k-curth);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将最左边一个元素作为基准然后partition，返回基准位置</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x = nums[left];<br>        <span class="hljs-type">int</span> i = left, j = right;<br>        <span class="hljs-keyword">while</span>(i&lt;j) &#123;<br>            <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; nums[j] &gt;= x) j--;<br>            <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; nums[i] &lt;= x) i++;<br>            <span class="hljs-built_in">swap</span>(nums[i],nums[j]);<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[i],nums[left]);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>) + left;<br>        <span class="hljs-built_in">swap</span>(nums[i], nums[left]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(nums,left,right);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="partition用for循环的版本（容易导致分布不均）："><a href="#partition用for循环的版本（容易导致分布不均）：" class="headerlink" title="partition用for循环的版本（容易导致分布不均）："></a>partition用for循环的版本（容易导致分布不均）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(T[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, Comparator&lt;T&gt; comparator)</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[high];  <span class="hljs-comment">// 1. 选最后一个元素为基准（固定）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low - <span class="hljs-number">1</span>;      <span class="hljs-comment">// 2. 小元素边界指针（初始在low前面）</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low; j &lt; high; j++) &#123;  <span class="hljs-comment">// 3. j遍历所有元素（除了基准）</span><br>        <span class="hljs-keyword">if</span> (comparator.compare(arr[j], pivot) &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 4. 当前元素 ≤ 基准</span><br>            i++;                       <span class="hljs-comment">// 小元素区域扩大</span><br>            swap(arr, i, j);           <span class="hljs-comment">// 把当前小元素放到小区域</span><br>        &#125;<br>    &#125;<br>    <br>    swap(arr, i + <span class="hljs-number">1</span>, high);  <span class="hljs-comment">// 5. 基准归位到小元素区域后面</span><br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;            <span class="hljs-comment">// 返回基准位置</span><br>&#125;<br></code></pre></td></tr></table></figure></h2><p>另一个类似的题目</p>
<ul>
<li>寻找两个正序数组的中位数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> m + n;<br>	<span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-comment">// 奇数：找第 (total/2 + 1) 小的元素</span><br>		<span class="hljs-keyword">return</span> getKth(nums1, nums2, total / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// 偶数：找第 (total/2) 小和第 (total/2 + 1) 小的平均数</span><br>	<span class="hljs-keyword">return</span> (getKth(nums1, nums2, total / <span class="hljs-number">2</span>) + getKth(nums1, nums2, total / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 在两个有序数组中找第k小的数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getKth</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;	<br>	<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">start1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, start2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 两个数组的起始位置	</span><br>	<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;	<br>		<span class="hljs-comment">// 边界情况</span><br>	<br>		<span class="hljs-keyword">if</span> (start1 == m) <span class="hljs-keyword">return</span> nums2[start2 + k - <span class="hljs-number">1</span>]; <span class="hljs-comment">// nums1用完</span><br>		<span class="hljs-keyword">if</span> (start2 == n) <span class="hljs-keyword">return</span> nums1[start1 + k - <span class="hljs-number">1</span>]; <span class="hljs-comment">// nums2用完</span><br>		<span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> Math.min(nums1[start1], nums2[start2]); <span class="hljs-comment">// 只剩1个要找的</span><br>	<br>		<span class="hljs-comment">// 正常情况</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> k / <span class="hljs-number">2</span>;	<br>		<span class="hljs-type">int</span> <span class="hljs-variable">end1</span> <span class="hljs-operator">=</span> Math.min(start1 + half, m) - <span class="hljs-number">1</span>; <span class="hljs-comment">// nums1的新位置		</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">end2</span> <span class="hljs-operator">=</span> Math.min(start2 + half, n) - <span class="hljs-number">1</span>; <span class="hljs-comment">// nums2的新位置  </span><br>	<br>		<span class="hljs-keyword">if</span> (nums1[end1] &lt;= nums2[end2]) &#123;<br>			<span class="hljs-comment">// 抛弃nums1的前半部分</span><br>			k -= (end1 - start1 + <span class="hljs-number">1</span>);<br>			start1 = end1 + <span class="hljs-number">1</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// 抛弃nums2的前半部分</span><br>			k -= (end2 - start2 + <span class="hljs-number">1</span>);<br>			start2 = end2 + <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="平衡二叉树AVL"><a href="#平衡二叉树AVL" class="headerlink" title="平衡二叉树AVL"></a>平衡二叉树AVL</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> height;<br>    Node *left, *right, *parent;<br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> key) : <span class="hljs-built_in">key</span>(key), <span class="hljs-built_in">height</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">parent</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(Node *N)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> N-&gt;height;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">(Node *N)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeight</span>(N-&gt;left) - <span class="hljs-built_in">getHeight</span>(N-&gt;right);<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">rightRotate</span><span class="hljs-params">(Node *y)</span> </span>&#123;<br>    Node *x = y-&gt;left;<br>    Node *T2 = x-&gt;right;<br><br>    x-&gt;right = y;<br>    y-&gt;left = T2;<br><br>    y-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(y-&gt;left), <span class="hljs-built_in">getHeight</span>(y-&gt;right)) + <span class="hljs-number">1</span>;<br>    x-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(x-&gt;left), <span class="hljs-built_in">getHeight</span>(x-&gt;right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">leftRotate</span><span class="hljs-params">(Node *x)</span> </span>&#123;<br>    Node *y = x-&gt;right;<br>    Node *T2 = y-&gt;left;<br><br>    y-&gt;left = x;<br>    x-&gt;right = T2;<br><br>    x-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(x-&gt;left), <span class="hljs-built_in">getHeight</span>(x-&gt;right)) + <span class="hljs-number">1</span>;<br>    y-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(y-&gt;left), <span class="hljs-built_in">getHeight</span>(y-&gt;right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">insert</span><span class="hljs-params">(Node *node, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key);<br><br>    <span class="hljs-keyword">if</span> (key &lt; node-&gt;key)<br>        node-&gt;left = <span class="hljs-built_in">insert</span>(node-&gt;left, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; node-&gt;key)<br>        node-&gt;right = <span class="hljs-built_in">insert</span>(node-&gt;right, key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> node;<br><br>    node-&gt;height = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(node-&gt;left), <span class="hljs-built_in">getHeight</span>(node-&gt;right));<br><br>    <span class="hljs-type">int</span> balance = <span class="hljs-built_in">getBalance</span>(node);<br><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123;<br>        node-&gt;left = <span class="hljs-built_in">leftRotate</span>(node-&gt;left);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123;<br>        node-&gt;right = <span class="hljs-built_in">rightRotate</span>(node-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>        cout &lt;&lt; root-&gt;key &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>        <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Node *root = <span class="hljs-literal">nullptr</span>;<br>    root = <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">30</span>);<br>    <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">40</span>);<br>    <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">insert</span>(root, <span class="hljs-number">25</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Preorder traversal of the constructed AVL tree is:\n&quot;</span>;<br>    <span class="hljs-built_in">preOrder</span>(root);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="先序遍历的非递归实现"><a href="#先序遍历的非递归实现" class="headerlink" title="先序遍历的非递归实现"></a>先序遍历的非递归实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> result;<br>    <br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>    <br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            result.add(node.val);     <span class="hljs-comment">// 访问当前节点</span><br>            stack.push(node);         <span class="hljs-comment">// 压栈</span><br>            node = node.left;         <span class="hljs-comment">// 遍历左子树</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = stack.pop().right; <span class="hljs-comment">// 回溯并转向右子树</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br>    <br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>        <span class="hljs-comment">// 一直往左走，把所有左节点压栈</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(current);<br>            current = current.left;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 弹出最左节点并访问</span><br>        current = stack.pop();<br>        result.add(current.val);<br>        <br>        <span class="hljs-comment">// 转向右子树</span><br>        current = current.right;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><pre><code>用于判断是否成环（最小生成树），用于求出连通分量个数，用于将某一部分剥离
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br>    <span class="hljs-comment">// 本题因为是按行列进行查找，优化可以直接采用哈希表</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 哈希表映射关系[key,parent]</span><br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; parent;<br>    <span class="hljs-comment">// 总共有多少不连通的并查集</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 并查集查找首领节点操作</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!parent.<span class="hljs-built_in">count</span>(index))&#123;<br>            parent[index] = index;<br>            count++;<br>        &#125;<br>        <span class="hljs-comment">// 查找并查集的首领节点并优化</span><br>        <span class="hljs-keyword">if</span>(parent[index] != index)<br>            parent[index] = <span class="hljs-built_in">Find</span>(parent[index]);<br>        <span class="hljs-keyword">return</span> parent[index];<br>    &#125;<br>    <span class="hljs-comment">// 并查集合并操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Uniod</span><span class="hljs-params">(<span class="hljs-type">int</span> index1,<span class="hljs-type">int</span> index2)</span></span>&#123;<br>        <span class="hljs-type">int</span> parent1 = <span class="hljs-built_in">Find</span>(index1);<br>        <span class="hljs-type">int</span> parent2 = <span class="hljs-built_in">Find</span>(index2);<br>        <span class="hljs-keyword">if</span>(parent1 != parent2)&#123;<br>            parent[parent1] = parent2;<br>            count--;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br>    <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> count) : <span class="hljs-built_in">count</span>(count) &#123;<br>        parent.<span class="hljs-built_in">resize</span>(count);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;count;i++) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pa = <span class="hljs-built_in">Find</span>(a);<br>        <span class="hljs-type">int</span> pb = <span class="hljs-built_in">Find</span>(b);<br>        <span class="hljs-keyword">if</span>(pa != pb) &#123;<br>            parent[pa] = pb;<br>            count--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x!=parent[x]) &#123;<br>            parent[x] = <span class="hljs-built_in">Find</span>(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h2><pre><code>分量指的是----一个图中的局部区域
连通指的是图中任意两个点之间可以到达。
强联通针对的是有向图
弱连通针对的是将有向图看成无向图（无向图里叫连通分量，可以用UnionFind求）
</code></pre>
<p>DAG的连通分量就叫强联通分量<br>逆后序遍历是使用dfs遍历然后反过来，可以用作先子后父的拓扑排序</p>
<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><p>对于无向图，直接DFS就能遍历到一个连通分量的所有点，所以很简单</p>
<h3 id="有向图-强联通分量-Kosaraju-和-Tarjan"><a href="#有向图-强联通分量-Kosaraju-和-Tarjan" class="headerlink" title="有向图(强联通分量) Kosaraju 和 Tarjan"></a>有向图(强联通分量) Kosaraju 和 Tarjan</h3><p>经典算法<br>先进行dfs，记录结束访问的顺序（出栈&#x2F;无后续节点可访问的顺序）<br>然后将这个顺序倒序，将图转置<br>然后根据现在的顺序进行dfs，<em><strong>每次得到一个强联通分量</strong></em></p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim算法（稠密图）"><a href="#Prim算法（稠密图）" class="headerlink" title="Prim算法（稠密图）"></a>Prim算法（稠密图）</h3><ul>
<li>优先队列存储到所有点的权重（距离）</li>
<li>取出权重最小的连接</li>
<li>以新加入的点更新剩余点（不在最小生成树里）的权重并加入</li>
</ul>
<h3 id="Kruskal算法（稀疏图）"><a href="#Kruskal算法（稀疏图）" class="headerlink" title="Kruskal算法（稀疏图）"></a>Kruskal算法（稀疏图）</h3><ul>
<li>排序所有边</li>
<li>通过并查集Find，查看是否联通，决定是否Union</li>
</ul>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><pre><code>回溯就是按照树的方式进行穷举
</code></pre>
<p>子集树（组合树）：<br class='item-img' data-src='/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122090908776.png'><img src="/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122090908776.png"><br>排列树：<br class='item-img' data-src='/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122090917930.png'><img src="/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122090917930.png"></p>
<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">20</span>];            <span class="hljs-comment">// a[i] 表示第 i 行皇后所在的列</span><br><span class="hljs-type">bool</span> flag_col[<span class="hljs-number">20</span>];    <span class="hljs-comment">// 列标记</span><br><span class="hljs-type">bool</span> flag_diag1[<span class="hljs-number">40</span>];  <span class="hljs-comment">// 主对角线标记</span><br><span class="hljs-type">bool</span> flag_diag2[<span class="hljs-number">40</span>];  <span class="hljs-comment">// 副对角线标记</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (row &gt; n) &#123;<br>        <span class="hljs-comment">// 找到一个解，输出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 尝试在当前行的每一列放置皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">1</span>; col &lt;= n; col++) &#123;<br>        <span class="hljs-keyword">if</span> (!flag_col[col] &amp;&amp; !flag_diag1[row + col] &amp;&amp; !flag_diag2[row - col + n]) &#123;<br>            <span class="hljs-comment">// 放置皇后</span><br>            a[row] = col;<br>            flag_col[col] = <span class="hljs-literal">true</span>;<br>            flag_diag1[row + col] = <span class="hljs-literal">true</span>;<br>            flag_diag2[row - col + n] = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-built_in">dfs</span>(row + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归尝试下一行</span><br><br>            <span class="hljs-comment">// 回溯，恢复标记</span><br>            flag_col[col] = <span class="hljs-literal">false</span>;<br>            flag_diag1[row + col] = <span class="hljs-literal">false</span>;<br>            flag_diag2[row - col + n] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45933509/article/details/122800784">图论学习-差分约束入门-CSDN博客</a></p>
<h2 id="topo排序"><a href="#topo排序" class="headerlink" title="topo排序"></a>topo排序</h2><pre><code>需要在 有向无环图(DAG)的条件下进行
</code></pre>
<p>一种是用队列，每次找入度为0的点，加入并更新<br>另一种用DFS：</p>
<ol>
<li><strong>初始化</strong>：对于有向图中的每个顶点，初始化一个访问状态，初始为未访问。</li>
<li><strong>递归遍历</strong>：从任意未访问的顶点开始进行深度优先搜索（DFS）。<ul>
<li>对于当前访问的顶点 v，将其标记为已访问。</li>
<li>递归遍历顶点 v 的所有邻接顶点，如果邻接顶点尚未访问，则继续递归遍历。</li>
</ul>
</li>
<li><strong>顶点访问结束时加入结果</strong>：在递归回溯时，将当前顶点加入到结果列表中，即将当前顶点放在结果列表的最前面，因为当前顶点的所有邻接顶点已经被访问过了。</li>
<li><strong>重复步骤2和3</strong>，直到所有顶点都被访问过。<br>比如两条路 A B C 和  A D C ，DFS 遍历顺序  A B C D 退出顺序 C B D A 拓扑顺序就是 ADBC</li>
</ol>
<h2 id="以图判树"><a href="#以图判树" class="headerlink" title="以图判树"></a>以图判树</h2><pre><code>用并查集检查
无环 -&gt; 树
+ 出入度满足 出度&lt;=2 除了根节点入度=1  -&gt; 二叉树
</code></pre>
<h1 id="自定义数据结构类考点"><a href="#自定义数据结构类考点" class="headerlink" title="自定义数据结构类考点"></a>自定义数据结构类考点</h1><h2 id="手写堆"><a href="#手写堆" class="headerlink" title="手写堆"></a>手写堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 堆化函数，调整堆的结构</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> largest = i;     <span class="hljs-comment">// 初始化最大元素为根节点</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左子节点</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>; <span class="hljs-comment">// 右子节点</span><br><br>    <span class="hljs-comment">// 如果左子节点大于根节点</span><br>    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])<br>        largest = left;<br><br>    <span class="hljs-comment">// 如果右子节点大于当前最大节点</span><br>    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])<br>        largest = right;<br><br>    <span class="hljs-comment">// 如果最大元素不是根节点，交换并递归堆化</span><br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        <span class="hljs-built_in">swap</span>(arr[i], arr[largest]);<br>        <span class="hljs-built_in">heapify</span>(arr, n, largest);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 堆排序函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 构建最大堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-built_in">heapify</span>(arr, n, i);<br><br>    <span class="hljs-comment">// 一个个从堆中取出元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);  <span class="hljs-comment">// 将当前最大元素移动到数组末尾</span><br>        <span class="hljs-built_in">heapify</span>(arr, i, <span class="hljs-number">0</span>);    <span class="hljs-comment">// 重新调整堆</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>  <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Compare = std::less&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> Heap &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;T&gt; data;<br>    Compare compare;<br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shift_up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (i != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">compare</span>(data[(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>],data[i])) &#123;<br>            std::<span class="hljs-built_in">swap</span>(data[i], data[(i<span class="hljs-number">-1</span>) / <span class="hljs-number">2</span>]);<br>            i = (i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shift_down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-type">int</span> childIndex;<br>        <span class="hljs-keyword">while</span>(i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt; data.<span class="hljs-built_in">size</span>()) &#123;<br>            childIndex = i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> ( childIndex + <span class="hljs-number">1</span> &lt; data.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">compare</span>(data[childIndex], data[childIndex+<span class="hljs-number">1</span>])) &#123;<br>                childIndex++;<br>            &#125;<br>            <span class="hljs-comment">// 如果父节点小于子节点，交换</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">compare</span>(data[i], data[childIndex])) &#123;<br>                std::<span class="hljs-built_in">swap</span>(data[i], data[childIndex]);<br>                i = childIndex;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        data.<span class="hljs-built_in">push_back</span>(value);<br>        <span class="hljs-built_in">shift_up</span>(data.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 原地构造并插入元素</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emplace</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>        data.<span class="hljs-built_in">emplace_back</span>(std::forward&lt;Args&gt;(args)...);<br>        <span class="hljs-built_in">shift_up</span>(data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) &#123;<br>            __throw_out_of_range(<span class="hljs-string">&quot;Heap is Empty&quot;</span>);<br>        &#125;<br>        T result = data[<span class="hljs-number">0</span>];<br>        data[<span class="hljs-number">0</span>] = data.<span class="hljs-built_in">back</span>();<br>        data.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-built_in">shift_down</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">empty</span>()) &#123;<br>            __throw_out_of_range(<span class="hljs-string">&quot;Heap is Empty&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[<span class="hljs-number">0</span>];<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="字典树Trie"><a href="#字典树Trie" class="headerlink" title="字典树Trie"></a>字典树Trie</h2><pre><code>用于解决前缀匹配问题
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>	unordered_map&lt;<span class="hljs-type">char</span>, Trie*&gt; children;<br>	<span class="hljs-type">bool</span> isEnd;<br>	string val; <span class="hljs-comment">// 如果结束了的话这里就是存储的对应的字符串结果</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><pre><code>特殊的平衡二叉查找树，针对区间问题，大区间的问题必须可以由小区间获得（比如区间最大最小值，和）
每个节点代表一个区间，a==b表示叶节点
共有b-a+1个叶节点
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1QT4y1Z7rR/?spm_id_from=333.337.search-card.all.click&vd_source=0952b02e1af85e198554b578ae18f4e7">看动画，完全搞懂线段树，线段树的算法设计与实现，打ACM必会，动画版+讲师版_哔哩哔哩_bilibili</a></p>
<p>优势：<br class='item-img' data-src='/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122091020726.png'><img src="/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122091020726.png"></p>
<p>父节点表示的区间和子节点的关系：<br class='item-img' data-src='/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122091028957.png'><img src="/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122091028957.png"><br>存储方式（用数组存）：数组的大小为 a[0] 到 a[b×2+2]，有些位置没有数据<br class='item-img' data-src='/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122091031982.png'><img src="/2024/03/24/hello-world/%E8%83%8C%E8%AF%B5/file-20251122091031982.png"></p>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><pre><code>实际上就是BFS变体
使用优先队列实现的该算法可以用来求最大路径，即每次取出最大的，看能不能更新的更大
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;<br>	<span class="hljs-type">int</span> id;<br>	<span class="hljs-type">double</span> distFromStart;<br>	<span class="hljs-comment">// 再写个构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用优先队列来保存State<br>按照  start开始到当前节点的已知最短路排序</p>
<p>每次从队列里面取出最短的一个节点<br>判断如果是end那就返回<br>如果当前取出的dist&lt;dist数组记录的值<br>    就continue（因为说明之前重复遍历了）</p>
<p>遍历他的相邻节点，让他们经过当前节点转一下<br>    如果转了之后更短了，那就更新dist数组并将节点新state加入队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">double</span> curMaxP;<br>    <span class="hljs-built_in">State</span>(<span class="hljs-type">int</span> id, <span class="hljs-type">double</span> curMaxP) : <span class="hljs-built_in">id</span>(id), <span class="hljs-built_in">curMaxP</span>(curMaxP) &#123;&#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> State&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-comment">// 在这里定义比较规则，例如根据状态的某些属性进行比较</span><br>        <span class="hljs-comment">// 这里假设状态有一个整数属性 value，根据 value 的大小来比较</span><br>        <span class="hljs-keyword">return</span> curMaxP &lt; other.curMaxP;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">maxProbability</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="hljs-type">double</span>&gt;&amp; succProb, <span class="hljs-type">int</span> start_node, <span class="hljs-type">int</span> end_node)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建图</span><br>        vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>&gt;&gt;&gt; <span class="hljs-built_in">graph</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;edges.<span class="hljs-built_in">size</span>();i++) &#123;<br>            <span class="hljs-keyword">auto</span> edge = edges[i];<br>            <span class="hljs-type">int</span> from = edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = edge[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">double</span> weight = succProb[i];<br>            graph[from].<span class="hljs-built_in">push_back</span>(&#123;to,weight&#125;);<br>            graph[to].<span class="hljs-built_in">push_back</span>(&#123;from,weight&#125;);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 需要按照state排序，每次找最大的</span><br>        <span class="hljs-comment">//! 这里的state类可以换成pair&lt;double,int&gt;，这样会默认按照double排序</span><br>        priority_queue&lt;State&gt; pq;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">maxDist</span><span class="hljs-params">(n,<span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function">State <span class="hljs-title">start</span><span class="hljs-params">(start_node, <span class="hljs-number">1</span>)</span></span>;<br>        pq.<span class="hljs-built_in">push</span>(start);<br>        <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [curId, curMaxP] = pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-comment">// 找到当前最大的</span><br>            <span class="hljs-keyword">if</span>(curId == end_node) <span class="hljs-keyword">return</span> curMaxP;<br>            <span class="hljs-comment">// 如果比当前记录的还小那就算了</span><br>            <span class="hljs-keyword">if</span>(curMaxP &lt; maxDist[curId]) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 遍历他相邻节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [nexId, weight]:graph[curId]) &#123;<br>                <span class="hljs-type">double</span> newDist = curMaxP*weight;<br>                <span class="hljs-keyword">if</span>(maxDist[nexId] &lt; newDist) &#123;<br>                    <span class="hljs-comment">// 更大</span><br>                    maxDist[nexId] = newDist;<br>                    pq.<span class="hljs-built_in">push</span>(&#123;nexId, newDist&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>带路径记录的dijkstra<br><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805489282433024&page=0">1018 Public Bike Management - PAT (Advanced Level) Practice (pintia.cn)</a></p>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><pre><code>没有使用优先队列，就是普通队列，加上vis和负权边判断
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> vexNum, <span class="hljs-type">int</span> source)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    vector&lt;<span class="hljs-type">int</span>&gt; cnt;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; tag;<br>    cnt.<span class="hljs-built_in">resize</span>(vexNum);<br>    tag.<span class="hljs-built_in">resize</span>(vexNum);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vexNum; i++) &#123;<br>        dist[i] = INF;<br>        cnt[i] = <span class="hljs-number">0</span>;<br>        tag[i]  = <span class="hljs-literal">false</span>;<br>    &#125;<br>    q.<span class="hljs-built_in">push</span>(source);<br>    tag[source] = <span class="hljs-literal">true</span>;<br>    dist[source] = <span class="hljs-number">0</span>;<br>    path[source] = source + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//! tag确保每个顶点只被加入到队列一次，以防止重复处理</span><br>        tag[u] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; adjacentList[u].<span class="hljs-built_in">size</span>(); i++) &#123;<br>            Edge edge = adjacentList[u][i];<br>            <span class="hljs-keyword">if</span> (dist[edge.to] &gt; dist[u] + edge.weight) &#123;<br>                dist[edge.to] = dist[u] + edge.weight;<br>                path[edge.to] = u + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (!tag[edge.to]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(edge.to);<br>                    tag[edge.to] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-comment">// 出现负权环则返回失败</span><br>                    <span class="hljs-keyword">if</span> (++cnt[edge.to] &gt; vexNum) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++) &#123;<br>	graph[k][k] = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br>			graph[i][j] = <span class="hljs-built_in">min</span>(graph[i][j], graph[i][k]+graph[k][j]);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h2><ul>
<li>先进行角排序</li>
<li>然后维护一个栈<ul>
<li>栈内元素小于2，入栈</li>
<li>新的点在栈顶两个点连线左侧，入栈<ul>
<li>否则弹栈</li>
</ul>
</li>
</ul>
</li>
</ul>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2025/12/17/Tech/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%E8%A7%A3%E6%9E%90/">算法深度理解解析 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a><a onclick="BgmControl()"><svg id="bgm-control" viewBox="0 0 30 34" fill="currentColor" style="width: 24px; transition: transform .3s;margin-top: 4px"><path d="M25.998 23.422V11.29h3.999v12.132h-3.999zM19.497 6.234h4.001v22.243h-4.001V6.234zM12.998.867h4v32.978h-4V.867zm-6.5 5.367h4.001v22.243H6.498V6.234zm-6.5 5.056h4v12.132h-4V11.29z"></path></svg><audio id="bgm" src="/audio/bgm.mp3" loop crossorigin="anonymous"> </audio></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/amiya.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">Nervld Island™</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/RuspeciaNervld"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="mailto:WindNegev@gmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/245123239"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a><a class="social" target="_blank" rel="noopener" href="https://www.zhihu.com/people/warfarin-40"><i class="fab fa-zhihu" alt="Zhihu"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-number">1.</span> <span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lcm"><span class="toc-number">1.1.</span> <span class="toc-text">lcm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E8%B4%A8%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">试除法判断是不是质数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">埃氏筛法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">线性筛法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">试除法分解质因数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E5%9B%A0%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%E6%95%B0%E5%80%BC%E5%92%8C"><span class="toc-number">1.4.</span> <span class="toc-text">求因数个数和数值和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">大数乘法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E8%BF%90%E7%AE%97"><span class="toc-number">1.6.</span> <span class="toc-text">快速幂运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">GCD求最大公约数，最小公倍数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85"><span class="toc-number">2.1.</span> <span class="toc-text">01背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">2.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">2.3.</span> <span class="toc-text">多重背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E8%83%8C%E5%8C%85"><span class="toc-number">2.4.</span> <span class="toc-text">排列背包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">KMP算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95quickSelect"><span class="toc-number">5.</span> <span class="toc-text">快速选择算法quickSelect</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#partition%E7%94%A8for%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%88%E5%AE%B9%E6%98%93%E5%AF%BC%E8%87%B4%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%EF%BC%89%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">partition用for循环的版本（容易导致分布不均）：1234567891011121314private static &lt;T&gt; int partition(T[] arr, int low, int high, Comparator&lt;T&gt; comparator) {    T pivot &#x3D; arr[high];  &#x2F;&#x2F; 1. 选最后一个元素为基准（固定）    int i &#x3D; low - 1;      &#x2F;&#x2F; 2. 小元素边界指针（初始在low前面）        for (int j &#x3D; low; j &lt; high; j++) {  &#x2F;&#x2F; 3. j遍历所有元素（除了基准）        if (comparator.compare(arr[j], pivot) &lt;&#x3D; 0) {  &#x2F;&#x2F; 4. 当前元素 ≤ 基准            i++;                       &#x2F;&#x2F; 小元素区域扩大            swap(arr, i, j);           &#x2F;&#x2F; 把当前小元素放到小区域        }    }        swap(arr, i + 1, high);  &#x2F;&#x2F; 5. 基准归位到小元素区域后面    return i + 1;            &#x2F;&#x2F; 返回基准位置}</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL"><span class="toc-number">6.1.</span> <span class="toc-text">平衡二叉树AVL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.</span> <span class="toc-text">先序遍历的非递归实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.</span> <span class="toc-text">中序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">图论算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">7.1.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">7.2.</span> <span class="toc-text">连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">7.2.1.</span> <span class="toc-text">无向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE-%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F-Kosaraju-%E5%92%8C-Tarjan"><span class="toc-number">7.2.2.</span> <span class="toc-text">有向图(强联通分量) Kosaraju 和 Tarjan</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">7.3.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95%EF%BC%88%E7%A8%A0%E5%AF%86%E5%9B%BE%EF%BC%89"><span class="toc-number">7.3.1.</span> <span class="toc-text">Prim算法（稠密图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95%EF%BC%88%E7%A8%80%E7%96%8F%E5%9B%BE%EF%BC%89"><span class="toc-number">7.3.2.</span> <span class="toc-text">Kruskal算法（稀疏图）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.</span> <span class="toc-text">回溯算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N%E7%9A%87%E5%90%8E"><span class="toc-number">7.5.</span> <span class="toc-text">N皇后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.6.</span> <span class="toc-text">差分约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#topo%E6%8E%92%E5%BA%8F"><span class="toc-number">7.7.</span> <span class="toc-text">topo排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%9B%BE%E5%88%A4%E6%A0%91"><span class="toc-number">7.8.</span> <span class="toc-text">以图判树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E8%80%83%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text">自定义数据结构类考点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%A0%86"><span class="toc-number">8.1.</span> <span class="toc-text">手写堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91Trie"><span class="toc-number">8.2.</span> <span class="toc-text">字典树Trie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">8.3.</span> <span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">Dijkstra算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPFA"><span class="toc-number">8.5.</span> <span class="toc-text">SPFA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Floyd"><span class="toc-number">8.6.</span> <span class="toc-text">Floyd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">8.7.</span> <span class="toc-text">凸包问题</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>