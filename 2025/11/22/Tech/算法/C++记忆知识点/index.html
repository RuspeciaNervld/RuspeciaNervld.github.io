<!DOCTYPE html><html lang="zh" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>C++记忆知识点 | Nervld的小窝</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.woff2"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><meta name="page-config" content="{&quot;code_fold&quot;:null}"><script class="pjax-js">var config = {"root":"/","code_fold":15,"search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}};
var page_config = {
  code_fold: null
};
function updatePageConfig() {
  var newPageConfig = document.querySelector('meta[name="page-config"]');
  if (newPageConfig) {
    page_config = JSON.parse(newPageConfig.content);
  }
}
document.addEventListener('pjax:complete', function() { updatePageConfig(); });
updatePageConfig();</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('/img/mybg3.png');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer src="https://vercount.one/js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.vercount','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => {
 const script = document.createElement('script');
 script.src = 'https://vercount.one/js';
 document.head.appendChild(script);
});reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.vercount','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => {
 const script = document.createElement('script');
 script.src = 'https://vercount.one/js';
 document.head.appendChild(script);
});reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>C++记忆知识点</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2025-11-22T01:11:48.760Z" id="date"> 2025-11-22</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2025-11-22T01:12:32.153Z" id="updated"> 2025-11-22</time></div></span><br><span>文章总字数: <div class="control">2.7k</div></span><br><span>预计阅读时间: <div class="control">12 分钟</div></span><br><span id="vercount_container_page_pv">页面浏览: <span class="control" id="vercount_value_page_pv">加载中...</span></span></div></div><hr><div id="post-content"><p>不同类型的最大值<br>在 &lt;limits.h&gt;里面<br>c++就引入 &lt;climits&gt; </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>最大值（科学计数法）</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>2e9</td>
</tr>
<tr>
<td>unsigned int</td>
<td>4e9</td>
</tr>
<tr>
<td>long long</td>
<td>9e18</td>
</tr>
</tbody></table>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在 C++ 中，字符串操作非常常见。以下是一些常用的字符串操作方法和函数，主要是基于 <code>std::string</code> 类。</p>
<h3 id="1-字符串初始化"><a href="#1-字符串初始化" class="headerlink" title="1. 字符串初始化"></a>1. <strong>字符串初始化</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str1 = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-function">std::string <span class="hljs-title">str2</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello, World!&quot;</span>)</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">str3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>)</span></span>;  <span class="hljs-comment">// &quot;AAAAAAAAAA&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="2-字符串连接"><a href="#2-字符串连接" class="headerlink" title="2. 字符串连接"></a>2. <strong>字符串连接</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str1 = <span class="hljs-string">&quot;Hello, &quot;</span>;<br>std::string str2 = <span class="hljs-string">&quot;World!&quot;</span>;<br>std::string result = str1 + str2;  <span class="hljs-comment">// &quot;Hello, World!&quot;</span><br>str1 += str2;  <span class="hljs-comment">// str1 变成 &quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="3-获取字符串长度"><a href="#3-获取字符串长度" class="headerlink" title="3. 获取字符串长度"></a>3. <strong>获取字符串长度</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">size_t</span> len = str.<span class="hljs-built_in">length</span>();  <span class="hljs-comment">// len = 13</span><br></code></pre></td></tr></table></figure>
<h3 id="4-访问字符串中的字符"><a href="#4-访问字符串中的字符" class="headerlink" title="4. 访问字符串中的字符"></a>4. <strong>访问字符串中的字符</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">char</span> ch = str[<span class="hljs-number">1</span>];  <span class="hljs-comment">// &#x27;e&#x27;</span><br>str[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">// str 变成 &quot;Hallo&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="5-字符串比较"><a href="#5-字符串比较" class="headerlink" title="5. 字符串比较"></a>5. <strong>字符串比较</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>std::string str2 = <span class="hljs-string">&quot;def&quot;</span>;<br><span class="hljs-type">bool</span> isEqual = (str1 == str2);  <span class="hljs-comment">// false</span><br><span class="hljs-type">bool</span> isLess = (str1 &lt; str2);  <span class="hljs-comment">// true, 因为 &quot;abc&quot; 小于 &quot;def&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="6-查找子字符串"><a href="#6-查找子字符串" class="headerlink" title="6. 查找子字符串"></a>6. <strong>查找子字符串</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">size_t</span> pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;World&quot;</span>);  <span class="hljs-comment">// pos = 7</span><br><br><span class="hljs-keyword">if</span> (pos != std::string::npos) &#123;<br>    <span class="hljs-comment">// &quot;World&quot; 被找到</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-获取子字符串"><a href="#7-获取子字符串" class="headerlink" title="7. 获取子字符串"></a>7. <strong>获取子字符串</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::string substr = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// &quot;World&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="8-替换子字符串"><a href="#8-替换子字符串" class="headerlink" title="8. 替换子字符串"></a>8. <strong>替换子字符串</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>str.<span class="hljs-built_in">replace</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;C++&quot;</span>);  <span class="hljs-comment">// str 变成 &quot;Hello, C++!&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="9-插入子字符串"><a href="#9-插入子字符串" class="headerlink" title="9. 插入子字符串"></a>9. <strong>插入子字符串</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello!&quot;</span>;<br>str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;, World&quot;</span>);  <span class="hljs-comment">// str 变成 &quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="10-删除子字符串"><a href="#10-删除子字符串" class="headerlink" title="10. 删除子字符串"></a>10. <strong>删除子字符串</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>);  <span class="hljs-comment">// str 变成 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="11-字符串转换为-C-风格字符串"><a href="#11-字符串转换为-C-风格字符串" class="headerlink" title="11. 字符串转换为 C 风格字符串"></a>11. <strong>字符串转换为 C 风格字符串</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = str.<span class="hljs-built_in">c_str</span>();  <span class="hljs-comment">// cstr 是 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="12-字符串拆分"><a href="#12-字符串拆分" class="headerlink" title="12. 字符串拆分"></a>12. <strong>字符串拆分</strong></h3><p>C++ 标准库中没有直接的字符串拆分函数，但可以通过 <code>find</code> 和 <code>substr</code> 来实现拆分操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str, <span class="hljs-type">char</span> delimiter)</span> </span>&#123;<br>    std::vector&lt;std::string&gt; tokens;<br>    std::string token;<br>    <span class="hljs-function">std::istringstream <span class="hljs-title">tokenStream</span><span class="hljs-params">(str)</span></span>;<br>    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(tokenStream, token, delimiter)) &#123;<br>        tokens.<span class="hljs-built_in">push_back</span>(token);<br>    &#125;<br>    <span class="hljs-keyword">return</span> tokens;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>std::string str = <span class="hljs-string">&quot;apple,banana,cherry&quot;</span>;<br>std::vector&lt;std::string&gt; fruits = <span class="hljs-built_in">split</span>(str, <span class="hljs-string">&#x27;,&#x27;</span>);  <span class="hljs-comment">// [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]</span><br></code></pre></td></tr></table></figure>
<h3 id="13-去除字符串首尾空白字符"><a href="#13-去除字符串首尾空白字符" class="headerlink" title="13. 去除字符串首尾空白字符"></a>13. <strong>去除字符串首尾空白字符</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale&gt;</span></span><br><br><span class="hljs-comment">// 去除左侧空白</span><br><span class="hljs-function">std::string <span class="hljs-title">ltrim</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span> </span>&#123;<br>    std::string result = s;<br>    result.<span class="hljs-built_in">erase</span>(result.<span class="hljs-built_in">begin</span>(), std::<span class="hljs-built_in">find_if</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ch) &#123;<br>        <span class="hljs-keyword">return</span> !std::<span class="hljs-built_in">isspace</span>(ch);<br>    &#125;));<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 去除右侧空白</span><br><span class="hljs-function">std::string <span class="hljs-title">rtrim</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span> </span>&#123;<br>    std::string result = s;<br>    result.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">find_if</span>(result.<span class="hljs-built_in">rbegin</span>(), result.<span class="hljs-built_in">rend</span>(), [](<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ch) &#123;<br>        <span class="hljs-keyword">return</span> !std::<span class="hljs-built_in">isspace</span>(ch);<br>    &#125;).<span class="hljs-built_in">base</span>(), result.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 去除两侧空白</span><br><span class="hljs-function">std::string <span class="hljs-title">trim</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ltrim</span>(<span class="hljs-built_in">rtrim</span>(s));<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="14-转换大小写"><a href="#14-转换大小写" class="headerlink" title="14. 转换大小写"></a>14. <strong>转换大小写</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 转换为小写</span><br>std::<span class="hljs-built_in">transform</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), str.<span class="hljs-built_in">begin</span>(), ::tolower);<br><br><span class="hljs-comment">// 转换为大写</span><br>std::<span class="hljs-built_in">transform</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), str.<span class="hljs-built_in">begin</span>(), ::toupper);<br></code></pre></td></tr></table></figure>
<h3 id="15-判断字符串是否为空"><a href="#15-判断字符串是否为空" class="headerlink" title="15. 判断字符串是否为空"></a>15. <strong>判断字符串是否为空</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">bool</span> isEmpty = str.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h1 id="STL库"><a href="#STL库" class="headerlink" title="STL库"></a>STL库</h1><h2 id="cmath"><a href="#cmath" class="headerlink" title="cmath"></a>cmath</h2><p><code>&lt;cmath&gt;</code> 是 C++ 标准库中的一个头文件，它提供了一系列用于数学运算的常用函数。以下是 <code>&lt;cmath&gt;</code> 中一些常用的函数：</p>
<ol>
<li><strong>三角函数</strong>：<ul>
<li><code>sin(x)</code>: 返回角度 x 的正弦值。</li>
<li><code>cos(x)</code>: 返回角度 x 的余弦值。</li>
<li><code>tan(x)</code>: 返回角度 x 的正切值。</li>
<li><code>asin(x)</code>: 返回 x 的反正弦值。</li>
<li><code>acos(x)</code>: 返回 x 的反余弦值。</li>
<li><code>atan(x)</code>: 返回 x 的反正切值。</li>
</ul>
</li>
<li><strong>指数和对数函数</strong>：<ul>
<li><code>exp(x)</code>: 返回 e 的 x 次方。</li>
<li><code>log(x)</code>: 返回 x 的自然对数。</li>
<li><code>log10(x)</code>: 返回 x 的以 10 为底的对数。</li>
<li><code>pow(x, y)</code>: 返回 x 的 y 次方。</li>
<li><code>sqrt(x)</code>: 返回 x 的平方根。</li>
</ul>
</li>
<li><strong>取整函数</strong>：<ul>
<li><code>ceil(x)</code>: 向上取整。</li>
<li><code>floor(x)</code>: 向下取整。</li>
<li><code>round(x)</code>: 四舍五入到最近的整数。</li>
<li><code>trunc(x)</code>: 截断小数部分，保留整数部分。</li>
</ul>
</li>
<li><strong>其他常用函数</strong>：<ul>
<li><code>fabs(x)</code>: 返回 x 的绝对值。</li>
<li><code>fmod(x, y)</code>: 返回 x 除以 y 的余数。</li>
</ul>
</li>
</ol>
<h2 id="climits"><a href="#climits" class="headerlink" title="climits"></a>climits</h2><ul>
<li><code>CHAR_BIT</code>：定义了一个字节中位数的位数，通常是 8。</li>
<li><code>SCHAR_MIN</code> 和 <code>SCHAR_MAX</code>：分别定义了有符号字符类型 <code>signed char</code> 的最小值和最大值。</li>
<li><code>UCHAR_MAX</code>：定义了无符号字符类型 <code>unsigned char</code> 的最大值。</li>
<li><code>CHAR_MIN</code> 和 <code>CHAR_MAX</code>：分别定义了字符类型 <code>char</code> 的最小值和最大值，这取决于 <code>char</code> 是否被定义为有符号或无符号。</li>
<li><code>MB_LEN_MAX</code>：定义了多字节字符的最大字节数。</li>
<li><code>SHRT_MIN</code> 和 <code>SHRT_MAX</code>：分别定义了短整型 <code>short</code> 的最小值和最大值。</li>
<li><code>USHRT_MAX</code>：定义了无符号短整型 <code>unsigned short</code> 的最大值。</li>
<li><code>INT_MIN</code> 和 <code>INT_MAX</code>：分别定义了整型 <code>int</code> 的最小值和最大值。</li>
<li><code>UINT_MAX</code>：定义了无符号整型 <code>unsigned int</code> 的最大值。</li>
<li><code>LONG_MIN</code> 和 <code>LONG_MAX</code>：分别定义了长整型 <code>long</code> 的最小值和最大值。</li>
<li><code>ULONG_MAX</code>：定义了无符号长整型 <code>unsigned long</code> 的最大值。</li>
<li><code>LLONG_MIN</code> 和 <code>LLONG_MAX</code>：分别定义了长长整型 <code>long long</code> 的最小值和最大值（C++11 引入）。</li>
<li><code>ULLONG_MAX</code>：定义了无符号长长整型 <code>unsigned long long</code> 的最大值（C++11 引入）。</li>
<li><code>DBL_EPSILON</code>：表示 <code>double</code> 类型能表示的最小正数，其值大约是 <code>2.2204460492503131e-16</code>。</li>
<li><code>FLT_EPSILON</code>：表示 <code>float</code> 类型能表示的最小正数，其值大约是 <code>1.192092896e-7F</code>。</li>
</ul>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><p>求vector中最大的元素索引</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> max_it = <span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><span class="hljs-type">int</span> max_idx = <span class="hljs-built_in">distance</span>(nums.<span class="hljs-built_in">begin</span>(), max_it);<br></code></pre></td></tr></table></figure>
<p>比较vector大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br><br><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">lexicographical_compare</span>(vec1.<span class="hljs-built_in">begin</span>(), vec1.<span class="hljs-built_in">end</span>(), vec2.<span class="hljs-built_in">begin</span>(), vec2.<span class="hljs-built_in">end</span>()) ) &#123;<br>    <span class="hljs-comment">// vec1 在字典序上小于 vec2</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 注意这里定义在class外</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), compare);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="自定义类型的hash"><a href="#自定义类型的hash" class="headerlink" title="自定义类型的hash"></a>自定义类型的hash</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash</span>&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;TreeNode*, TreeNode*&gt;&amp; p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 计算哈希值</span><br>        <span class="hljs-type">size_t</span> hash1 = hash&lt;TreeNode*&gt;&#123;&#125;(p.first);<br>        <span class="hljs-type">size_t</span> hash2 = hash&lt;TreeNode*&gt;&#123;&#125;(p.second);<br>        <span class="hljs-keyword">return</span> hash1 ^ (hash2 &lt;&lt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 结合第一个和第二个哈希值以生成最终的哈希值</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h2><p>可以通过下面的方式来解构元组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> [pr, node] = xxxx<br></code></pre></td></tr></table></figure>
<p>c++中元组是有 默认实现的 <strong>比较函数</strong> 的</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ol>
<li><strong>基本操作：</strong><ul>
<li><code>length()</code> 或 <code>size()</code>: 返回字符串的长度。</li>
<li><code>append(str)</code> 或 <code>+</code>: 将字符串追加到另一个字符串后面。</li>
<li><code>insert(pos, str)</code>: 在指定位置插入字符串。</li>
<li><code>erase(pos, len)</code>: 删除指定位置开始的指定长度的字符。</li>
<li><code>replace(pos, len, str)</code>: 用另一个字符串替换部分字符串。</li>
<li><code>substr(pos, len)</code>: 提取子字符串。</li>
</ul>
</li>
<li><strong>访问字符：</strong><ul>
<li><code>at(pos)</code> 或 <code>operator[]</code>: 返回指定位置的字符。</li>
<li><code>front()</code> 和 <code>back()</code>: 返回第一个和最后一个字符。</li>
</ul>
</li>
<li><strong>查找和比较：</strong><ul>
<li><code>find(str, pos)</code>: 在字符串从pos位置从左向右查找子字符串。pos默认0</li>
<li><code>rfind(str, pos)</code>: 从字符串的pos位置从末尾开始查找子字符串。pos默认末尾</li>
<li><code>compare(str)</code>: 比较两个字符串。</li>
</ul>
</li>
<li><strong>转换：</strong><ul>
<li><code>to_string(val)</code>: 将数值类型转换为字符串。</li>
<li><code>stoi()</code>, <code>stof()</code>, <code>stod()</code>, <code>stol()</code>, <code>stoll()</code>, <code>stoul()</code>, <code>stoull()</code>: 将字符串转换为数值类型。</li>
<li><code>c_str()</code>: 返回以 null 结尾的 C 字符串。</li>
</ul>
</li>
</ol>
<h2 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h2><pre><code>可以结合文件，即#include &lt;fstream&gt;
其中ofstream和ifstream分布代表输出，输入文件
通过传入路径来构造类，is_open判断状态, close来关闭
用 《  的方向来表示数据流的方向
</code></pre>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>遍历方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = myUnorderedSet.<span class="hljs-built_in">begin</span>(); it != myUnorderedSet.<span class="hljs-built_in">end</span>(); ++it)<br>&#123; <br>	std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : myUnorderedSet) <br>&#123;<br>	std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : myUnorderedSet) <br>&#123;<br>	std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure>


<p>利用迭代器来用vector构造set</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">set&lt;string&gt; <span class="hljs-title">deadendsOrVis</span><span class="hljs-params">(deadends.begin(),deadends.end())</span></span>;<br></code></pre></td></tr></table></figure>
<p>注意set会自动排序，按照数值，unordered_set则不会</p>
<h2 id="priority-queue-优先队列-heap-堆"><a href="#priority-queue-优先队列-heap-堆" class="headerlink" title="priority_queue 优先队列 &#x2F; heap 堆"></a>priority_queue 优先队列 &#x2F; heap 堆</h2><p><em><strong>只需记住c++堆默认大顶堆，排序默认升序。 用的都是less比较函数即可</strong></em></p>
<p>创建优先队列的时候需要传入一个类<br>（如果需要自定义，还会加上vector&lt;类&gt;, Comp或者greater&lt;类&gt;）<br>也可以通过&#x3D;&#x3D;重载&lt;运算符&#x3D;&#x3D;的方式来实现自定义。</p>
<p>c++ 默认大顶堆，填上greater函数可以改成小顶堆，a&gt;b是greater函数</p>
<p>在 C++ 中，当你想要创建一个自定义的比较器（Comparator）来指定元素的比较规则时，你通常会重载括号运算符 <code>operator()</code>。这是因为在标准库中，像 <code>priority_queue</code> 这样的容器通常使用函数对象（Function Object）来进行比较操作。<br>&#x3D;&#x3D;默认less大顶堆， &lt;   ,   降序&#x3D;&#x3D;<br>&#x3D;&#x3D;用greater改为小顶堆， &gt; ,   升序&#x3D;&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Comp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>        <span class="hljs-comment">// 自定义比较规则，比如按照第一个元素的大小进行比较</span><br>        <span class="hljs-keyword">return</span> a.first &lt; b.first;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这样，当你使用 <code>priority_queue</code> 时，它将使用 <code>Comp</code> 中定义的比较规则来确定元素的顺序。</p>
<p>排序时用sort不一样，那个要<strong>传入的是一个函数</strong>，可以用lambda或者外面写函数。<br>对于函数 &lt; 表示升序</p>
<p>大顶堆，就是每个节点都大于等于子节点的完全二叉树。但是使用的比较函数却是小于，因为要在父节点的值小于子节点的值时进行调整</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li><strong><code>vector</code>常见操作</strong>：<ul>
<li><strong>初始化</strong>：创建<code>vector</code>并设置初始大小和默认值。</li>
<li><strong>访问元素</strong>：使用<code>[]</code>或<code>at</code>方法访问元素。</li>
<li><strong>添加元素</strong>：<code>push_back</code>、<code>insert</code>、<code>emplace_back</code>。</li>
<li><strong>删除元素</strong>：<code>pop_back</code>、<code>erase</code>、<code>clear</code>。</li>
<li><strong>获取大小和容量</strong>：<code>size</code>、<code>capacity</code>、<code>empty</code>。</li>
<li><strong>修改容量</strong>：<code>reserve</code>、<code>shrink_to_fit</code>。</li>
<li><strong>遍历元素</strong>：<code>for</code>循环、<code>range-based for</code>、迭代器。</li>
</ul>
</li>
<li>**<code>resize</code>**：<ul>
<li><strong>增加大小</strong>：添加新元素，已有元素不变。</li>
<li><strong>减少大小</strong>：移除超出部分的元素，保留的元素不变。</li>
</ul>
</li>
<li><code>assign</code>：不改变大小清空元素</li>
</ul>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul>
<li>set和map都是有序的，底层是红黑树</li>
<li>只有前面加了unordered才是无序</li>
</ul>
<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>对于<code>unordered_map</code>，同样可以使用迭代器或范围循环进行遍历。下面是两种方法的示例：</p>
<ol>
<li><p>使用迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;One&quot;</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Two&quot;</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Three&quot;</span>&#125;&#125;;<br>    <br>    <span class="hljs-comment">// 使用迭代器遍历unordered_map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = myMap.<span class="hljs-built_in">begin</span>(); it != myMap.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用范围循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;One&quot;</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Two&quot;</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Three&quot;</span>&#125;&#125;;<br>    <br>    <span class="hljs-comment">// 使用范围循环遍历unordered_map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>无序映射(<code>unordered_map</code>)的遍历方式与有序映射(<code>map</code>)基本相同。</p>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><p>按照格式读入和输出<br class='item-img' data-src='/2024/03/24/hello-world/%E5%BF%86%E7%9F%A5%E8%AF%86%E7%82%B9/file-20251122091227855.png'><img src="/2024/03/24/hello-world/%E5%BF%86%E7%9F%A5%E8%AF%86%E7%82%B9/file-20251122091227855.png"></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2025/11/22/Course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">← 下一篇 计算机视觉-兴军亮</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2025/11/22/Tech/%E7%AE%97%E6%B3%95/PAT&amp;CSP&amp;%E8%93%9D%E6%A1%A5%E6%9D%AF/">PAT&amp;CSP&amp;蓝桥杯 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a><a onclick="BgmControl()"><svg id="bgm-control" viewBox="0 0 30 34" fill="currentColor" style="width: 24px; transition: transform .3s;margin-top: 4px"><path d="M25.998 23.422V11.29h3.999v12.132h-3.999zM19.497 6.234h4.001v22.243h-4.001V6.234zM12.998.867h4v32.978h-4V.867zm-6.5 5.367h4.001v22.243H6.498V6.234zm-6.5 5.056h4v12.132h-4V11.29z"></path></svg><audio id="bgm" src="/audio/bgm.mp3" loop crossorigin="anonymous"> </audio></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/amiya.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">Nervld Island™</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/RuspeciaNervld"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="mailto:WindNegev@gmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/245123239"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a><a class="social" target="_blank" rel="noopener" href="https://www.zhihu.com/people/warfarin-40"><i class="fab fa-zhihu" alt="Zhihu"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">1. 字符串初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.</span> <span class="toc-text">2. 字符串连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">3. 获取字符串长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">4. 访问字符串中的字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">1.5.</span> <span class="toc-text">5. 字符串比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9F%A5%E6%89%BE%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.</span> <span class="toc-text">6. 查找子字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%8E%B7%E5%8F%96%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.7.</span> <span class="toc-text">7. 获取子字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%9B%BF%E6%8D%A2%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.8.</span> <span class="toc-text">8. 替换子字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%8F%92%E5%85%A5%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.9.</span> <span class="toc-text">9. 插入子字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%88%A0%E9%99%A4%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.10.</span> <span class="toc-text">10. 删除子字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA-C-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.11.</span> <span class="toc-text">11. 字符串转换为 C 风格字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86"><span class="toc-number">1.12.</span> <span class="toc-text">12. 字符串拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">1.13.</span> <span class="toc-text">13. 去除字符串首尾空白字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%BD%AC%E6%8D%A2%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">1.14.</span> <span class="toc-text">14. 转换大小写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.15.</span> <span class="toc-text">15. 判断字符串是否为空</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%BA%93"><span class="toc-number"></span> <span class="toc-text">STL库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cmath"><span class="toc-number">1.</span> <span class="toc-text">cmath</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#climits"><span class="toc-number">2.</span> <span class="toc-text">climits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#algorithm"><span class="toc-number">3.</span> <span class="toc-text">algorithm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%9A%84hash"><span class="toc-number">4.</span> <span class="toc-text">自定义类型的hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pair"><span class="toc-number">5.</span> <span class="toc-text">Pair</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">6.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iostream"><span class="toc-number">7.</span> <span class="toc-text">iostream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-heap-%E5%A0%86"><span class="toc-number">9.</span> <span class="toc-text">priority_queue 优先队列 &#x2F; heap 堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-number">10.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-number">11.</span> <span class="toc-text">STL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">遍历方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">12.1.</span> <span class="toc-text">map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number"></span> <span class="toc-text">输入输出</span></a></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>