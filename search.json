[{"title":"Hello World","url":"/2024/03/24/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Other"],"tags":["Other"]},{"title":"比较混乱的一天","url":"/2025/08/01/Diary/2025-08-01%20%E6%AF%94%E8%BE%83%E6%B7%B7%E4%B9%B1%E7%9A%84%E4%B8%80%E5%A4%A9/","content":"\n      \n        446254cdb18d9d93fdca03421e2479cc7e0958ffc99a22b69a86293abb5f1753a156a58dbef5b49603ebb9b3cea18aa7bb6420d93cd277d99b0765196f2058fd66223017a30b5d01189764cec54af9cf505bd22d446e6db1207f231bfc782e96556d0b67247b4b446f22b4f318990ce5206f5fa1be8edab64f395a2be46cf16798ee8b077c3a544d7753c7612748203662960b803499295a5433f38a6f6b7dba08d74b477b40469ef5e46d8ebaaabca574527addfe4120f57e7597436a979918e70d5834da8e2d014ce7a4868998c5c040f1c7a0a2829364abb42677474baa48c9883f84879d7958be15189b89e7e99d8d94a58ad6ce49074ba42b3b149041fef1c49d085ae28b51c6f73e9a5eafab3c6627ffb49a8e8f1928c2127a0428a190c8863a8327cb1472b4290b25448db5712392bd62c79e9c3e34d2a21b17fa274a830f8add6651f1e01db8dbd1ef9c0fa377589a8afdbde48eb95100315fa2c915c7c0b1af6ac277719440019a1695768b6954e5ee5db34c3310523dadacab00cf4c7d18bc58df5494b36c8748ac6153e399a32d0297fe5b6f95c38842475586f9a4415c7fcfd40a933c42f10ace8efa64258ce09e73bca4d803ffe78b9f9fadb502002d4c8424421574c548cf39d8977935d56801ea8601ca05c641dc3cd13b8edcaa4855cd21ab314fcddb7ef2deabf1b66500408406c2fe02aa455e7f936685d08952966b770564414a71827072348a3d5cfce65c4eb1f24381ad8a899acd6d6218f838e2b3631fc16e110dbf347c10a459db69e44da561a08215743eb6ef8e512bfb867af5962c32617676f284249c8d61791795954153aecd88f857e8a64fa8658296a12f4dc6270317e7678337ca76d616d7bef288b4e3e2b249da9d46806824716813589c6659f712db35118b95c601d8c50a7e6ebd54b91b386b7032d8321ad3ddc7c46c03b17de2723e50dd50903a8ed12f42026f172035989d310ee2e9d81630ae16e5c8a3b42996da69df9300ee40020085da8339d6e5d2343c4b3c3717aacbcabdd32a4740ecb9f08d4930c1c7d55b11ca99624a6db26991b0d920b350c7794042e716f68719558d2521a317def2ac341be3b4e2885bd94b83b08b49ad8f3e98e9c155c947627e943a633e00ccdf3581174fd474152e1e7fb0e4b16694c6837c476904330658e7df1fd26b566d9e64f18aa837b3579448a9d117cfae762be6438320a4689dafc1ac91a50da3a0c3c549919f6b1d3312b3254e6f25b4e4a4b8a971a937d23643d7135b7b0cffdf9030cdaf558acc0900bd2624450d9ac05b43ba6f7afb6e3f4adbb45ea7210d229b042411add69964883cb2c1e296f8c382e6464598496167dddcc37021e023c0de9720a44118100e1fa84381c9baa6092d1628c8e71872caf98ccffff7e60cb351de160bab23674f0dc9946cb9c59376129a3eed97b95183ab9111e95850dc323626892473a732f80cfa6287d012f623d730e3c1168f3db08a532779c445316f2fa278680ab63710392283571b9710bb680bf401b1f24d2f052ff920b62fdc247a634c66b348eded2cd2b3a42d45fe19b712566f31c51be6b29f34c0c063b7dbccec58d41895a1beb42c6779100616ccc92baf8b6a12e615e27b21e2005e8329887391006cda1b77ccc592b703d4844826b645baa3925cb81b7236b0ba4a9ad884a33f29b7f9a83a942b69e77d092550aa1f87202d52ad9d1bc783003bd7476b01c8c3f884914360644c6bd01e335f2c826c463cdf4c265349dddb918a07adb7eea2b853f7157556bfe7c32a3c65508523968d7ad67f71ae820726ca619a039f26caeabf1e9ed8214b4a6a34ab2a486383026f24f6bccc150205b9439ec91e4fe121cf1155661ac1dba47367c009db85709574e5372b423c4ff03d3389b6912c8f031a1ececae5487c018e0756db8ac598613a7346b6261fc9649864d9e64912f1cc7f40af6153b6123311133d2706c5036eb7e41656dfe1b79db28a1c292818e1c4e5106ea585eb4baab40784beda36ad1378b665bdcea4db917a4261c40ab4068e13753af87a899d8cf01d3ee265138168208f9d1fda0c2bd653ecfcf9dd53b7cd777ea1e4e741fe9e441781b6dad167cfad306aa78fed041a03b63fdb77ad617c5c5c6e970985337e27c74e373b4a61cf2a3ebd16dcb56c55ee2f89188cd842ff0a782f0d5348aa2444985b6b80756dbe6e0ca670200a85b8bc30d0bfe1d87cba6dc8a93b66afc9128abc315cf0e87baf48c597397b77c14465c60e475ff45adb18f42f8c936bc324f49c1eabebe249f9a17649dc431fa10375f765bbeba83627eb42e8756cc6cb25b74b074427c390f71c1643bfa93b95ae1f141cdfaf36c47bdd4d334a50ebd6d5f355ff78812e21aa4b631bf33c78d744aecc7587b8388fc072cf4a253254ba521fde4043961d6e702f32475bdf7319d9bef9d519396a0d4794b7e4c43ba8efc758eadd26708ed2a6c1fee1e80802cd3e5c962eac4733b7921b682ce9a7c19149c16a769828625a583b8d1a5d3b7926ca91b18d824b83ce415ce36f26c4de9b0ae8087b3dc364ae19a6fa23d468ab9e578b528aaae642eb69d5882a600066148fbf95168a5dbdc607ecaadc983ebd77cb4dd9f4111820f64be2e77283296d4be2c7e3a23f9da1a335074bed78f763391a339dad7b954cfcc647e0e2413b6eb54cb532d9296a6205699001dfb54949331da43b93cb9aeb3e71c728cd820dea3301853fe768a455a261c70a4a3caadb12293cb622a6fcf10bbc2e2c06a4b3dd867f0cb57e05370dedd5777092bcf3fa608e599deceae586965fa0f32eb674666cc403c92667919d091c9987edeab1251c041b78d9240a2278f02682995441b54eb074360611\n      \n      \n        \n          \n          \n            请输入与 Nervld Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    ","categories":["Diary"],"tags":["Diary","🌧️","😕","🚩"]},{"title":"First-Diary","url":"/2025/08/29/Diary/First-Diary/","content":"从今天开始，我就要更新自己的博客啦？敲开心ヾ(≧▽≦*)o \n\n那么今天主要是完成了主题的构建，目前长这样(&#x2F;ω＼)：怎么样，感觉还是不错的，有点游戏的感觉反正一步步构建就变成这样啦，哈哈😄接下来主要就集中在：\n\n把之前的笔记整理成博客\n构建一下方便的流程，总结一下也发成笔记\n\n\n今天晚上一定把Obsidian这边弄好，加油ヾ(≧▽≦*)o\n就在我打算创建快捷启动hexo指令的时候\n铛铛铛~~\nfluent search居然突然更新成win11风格UI了，感觉稳定性大大增加，˶╹ꇴ╹˶！\n","categories":["Diary"],"tags":["🚩","OpenDiary"]},{"title":"测试图片","url":"/2025/07/31/Servld/test-img/","content":"\n      \n        8341757e6ee988888cc17467f23dcd1e0e82e18bf4b577b651ea4ccd51ed10f77da19a5cdca1f479c85111432a84afcb7907a96751bc641e02c6d12f97e7f6448876b274f9108412d7926afc1a3ef623971e101218b5d6b6734918859458a3455b4c9a4b30335f62dd0076f169eab9cdbb1d78e8b232057aae7eda4fb1d6c2dce1e55880a5fdee4bf452771bbe1884285b19ac27b1d9e65b6ac03cb58ea65eaa93a2a58975a0d08d61ba7eddc8074222bc5a7485f7bf094e98418ce1dd524afa\n      \n      \n        \n          \n          \n            请输入与 Nervld Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    ","categories":["Servld"],"tags":["Servld"]},{"title":"ebs AI动画流程","url":"/2024/02/05/Tech/AIGC/ebs%20AI%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B/","content":"使用指令\nffmpeg -i file.mp4 -vf fps&#x3D;12 %d.png\n负面提示词：easynegative\n正面提示词：masterpiece, best quality, 1girl, solo\n提示词权重：(1girl:1.2)\n采样方式有：Euler系列和DPM++系列，可以在脚本中用X&#x2F;Y&#x2F;Z Plot对比\n常用高宽：512 &#x2F; 768 &#x2F; 1024\nControlnet\n\n过程\n将图片丢到tagger里面筛选出描述姿势的词\n\n使用三个controlnet\n\ntile   以promot为准\ndepth  权重0.6\nreference only   目标角色图片，需要扣掉背景\n\n\n\n02:  1girl, solo, , open mouth, 均匀, looking at viewer, simple background, smile, arms behind head,  cowboy shot, arms up\n输出ffmpeg -r 12 -f image2 -i %d.png output1.mp4\n补帧先速度拉满从12-&gt;24，再质量拉满从24-&gt;60\nEbs流程stage1 将视频拆成单帧输入一个项目路径\n输入文件路径，注意用\\斜杠\nstage1 生成蒙版将关键帧和全部帧分别生成蒙版到\nvideo_mask 和 video_key_mask\nstage2 给关键帧打上tag就是把反推出来的tag保存到源文件中\nstage3 进入图生图进行单帧渲染\n输入目录为关键帧，输出目录为img2img_key\n去噪强度和重绘幅度一致\nFirstGen回送源Current、\n启动single mode， maskinpaint，与图片名称匹配\n输入关键帧蒙版路径\n从文本文件读取提示词\nstage4 批量放大图片批量放大输出目录 img2img_upscale_key\nstage5 点击生成ebs文件stage7 点击生成视频stage8 替换视频背景知识采样器\n","categories":["Tech"],"tags":["AIGC"]},{"title":"MMD制作流程","url":"/2025/08/03/Tech/MMD/MMD%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/","content":"初始准备\n拖入人物场景模型\n拖入ray.x, ray_controller.pmx\n拖入天空盒的pmx\n修改绘制顺序skybox&gt;stage&gt;actor\n人物场景加上main.fx\nEnvLightMap给天空盒上fx，材质也要改成skybox，再加fog\n\n\n如果有旋转，main里也要改成一样的\n\n\n关闭显示地面阴影，抗锯齿，过滤各向异性\n\nMME各栏介绍Main：\nmain_ex_alpha:对天空盒透明\nmain_ex_mask:对场景透明\nmain_ex_noalpha:不透明\nmain_ex_with_sphmap:启用镜面插槽\n\nMaterialMap：\n通过photoshop&gt;滤镜&gt;3D创建材质的法线贴图和凹凸贴图，放在一个文件夹里，将matirial复制一份放进去，修改最后一行为..&#x2F;，还有贴图路径，再用这个material替换掉原来的\nreadme里有具体修改属性\n\nSSAOMap：&#x3D;&#x3D;在shadow里&#x3D;&#x3D;\n\n通过选择不同的SSAO.fx调整环境光遮蔽的程度\n\n建议：将人整体的系数调低，眼睛直接改为0\nPSSM:一共有四个，对应摄像机的四个方向，主要调整影子的有无\n\nSKYBOX:\n左上：色彩平衡\n左下：漫反射色彩平衡\n右上：\n光强，镜反射，次表面亮度（通透渡），光向\n\n\n右下：\n\nHSBV：固有色，纯度，亮度，强度\nSky Hemisphere：\n纯白背景天空盒，可以调颜色；\nSky Night：\n与上面类似，默认黑色；\nTime of Day：\n\nmain材质改为skybox材质\n再改EnvLightMap和FogMap(选最长的)\n\n特点：物理天空，丁达尔效应，调整太阳位置\n用法：可以在帧里注册照明操作，实现动画\n\n左上：太阳大小，强度，物理化，偏移，虚拟太阳高度\n左下：调整雾气\n右上：\n右下：调整云朵数量，运动\n\nRAY：\n左上：光强，阴影颜色·强度，环境光遮蔽，光线通透性(SSSS)\n右上：将ray.x追踪到模型，拉高MeasureMode\n左下：尽量不要先动，后期添加额外插件\n右下：调色\n\nMME插件使用LightBloom：\n背景&gt;附件设定，放在所有MME下面\n\nSpectrum：\n音频可视化\n\n将wav格式的音频拖到tool的run上\n替换对应的texture，将fx，pmx拖到mmd里\n删除动作镜头音乐左边的框中大筐筐底部的小框里可以更换一下选择范围，输入初始和结束帧，点击范围选择，删除。\n音乐直接拖入新的即可。ps:千万不要在播放时拖入音乐。\n调整模型位置人物和场景可以直接按选择全部后调整，相机需要根据人物更改中心\nPR使用配色方案可以试试:\n\nAdode 2\nAdobe -4\nSL BIG\nSL CLEAN KODAK A&#x2F;B&#x2F;C\nSL GOLD …\nSL NEUTRAL START\n\nPR导出设置\n- \n\n1080p目标比特率5.5,最大比特率23\n\n4K目标比特率19,最大比特率58\n\n音频AAC 48000Hz 320 优先比特率\n\n\nUnity插件导入人物模型，换成人形avatar\nBlender导入blender将人物按照材质切分后调整\n在水滴那一栏的刚体世界环境里的缓存下点 烘焙所有动力学计算结果，在这之前要材质切分\nblender添加材质主要用着色器-&gt;原理化BSDF并在右边连接材质输出（表面）\n勾选插件Node:Node Wrangler并选择原理化BSDF类型，快捷键ctrl+shift+t\n可以在左上角进入贴图文件夹，将贴图拖入\n材质输出需要折叠一下再展开\n选中贴入入口，回车 下 回车 一个个试\n选中整个人物（蒙皮+骨骼），可以右键，选择层级，导入动作\n导出材质：\n\n在shading页面新建做下新建贴图，\n\nMMD+Blender+UnityMMD先用MMD汉化版，导入模型动作，相机调零后选择追踪头，按住ctrl对焦眼睛后进入头部，点击注册保存\n之后通过英文版打开，MMDBridge里选blender，下面日文选短的，后面填长度和30fps（必须）\n导出分辨率200x200 帧率30fps （骼，到骨骼那一栏勾选插件，调参\n\n头发建议0.2&#x2F;0.2&#x2F;15&#x2F;0.2&#x2F;0.3&#x2F;0.2\n尾巴建议0.1&#x2F;0.2&#x2F;13&#x2F;0.5&#x2F;0&#x2F;2\n\n选择头发到编辑模式，选择全部，按M选择按距离，用L选择一部分，按P分离选中，就可以专心做头发了（最好反向选择，选少点），头发的部分要ctrl+j合并\n选择不想移动的部分，新建顶点组（绿色三角）并且指定\n物理（行星）那一栏，创建布料，在缓存里修改总帧数，在形状里将他订到我们之前创的组里，勾选压力和内部弹簧，调参，记得回到物体模式\n导出fbx勾选：选定的物体，类型为骨架和网格；路径模式选择复制，勾选右边的内嵌纹理\nUnity\n去Stereoarts Homepage下载插件MMD4Mecanim_Beta_20200105.zip\n导入两个unitypackage\n拖入人物模型文件夹，勾选同意协议后拖入动作vmd点击process\n\nscene里不显示光照把灯泡标志打开\n如果发现光照怎么调都调不对，可以看看场景的光照map，可以设置为none\n将人物导入，一个做模型，一个带动画，记得改名，然后将动画拖出来，放在自己的动画控制器上，并且也可备份（点一下模型，把动画名字改下，这下就可以复制了ctrl+D）转出动作之后一定要先把模型骨骼改成人形，动画改成减少关键帧0.2\n完成之后可以把pmx删掉，这样下次材质就不会乱了\n天空盒材质球一定要设置为cube形式，可以在HDRP Default Setting里设置，也可以通过在Volume里覆盖，记得把Visual Environment改成HDRI SKY，选择hdri天空发现黑的，改变intensity mode\nPBR:将材质的smoothness和metalic和coatMask调低，metalic和smoothness在中间左右，再给脸上打光；mask上纯蓝色的toon贴图\nhdrp的volume有默认（在project settings里），有全局有局部；另外graphics里面要和当前设定的挡位一致\n贴身衣物穿模要调整z offset\n一般调整：将bae&#x2F;shade feature拉高，shadowMap变黑，System Shadow降低，添加描边（如果加了没用就切换一下场景），basic lookdevs里面调整阴影，皮肤调整为棕红，其他为黑灰色\n头发绑骨骼：\n\n安装animation rigging和magica cloth\n选中角色在工具栏中可视化骨骼，如果要取消就把他的组件删掉\n在角色中新建一个magica bone cloth\n拖入根节点后按start Point Selection，红色为固定节点，绿色为移动，黑色为无关，检查好后按end\n在parameters里选择预设preset后create\n\n制作动画：\n\n在timeline里放入人物的动画器\n\n人物为通用形\n\n在人物下创建bonerenderer和RigBuilder\n\n空物体Rigs添加Rig，下面再添加空物体作为ik节点，按住ctrl选中手掌系欸但，点击工具栏里的align，再在下面添加twoBoneIK，分别放入手臂，手肘，手腕\n\n把自己拖到target里\n\n可以选中IK节点给他一个标识\n\n用finalik：\n\n在对应的位置创建target作为控制和记录的节点，可以把他们放在同一个空物体上\n\n\n\n在做裙子物理时要往下来点，否则会出现鼓包\n实景合成\n将素材放入ae左上后拖入合成，左上角出现的预合成改成30帧，将他拖入合成，获得目标素材\n\n右侧找到跟踪器，点击跟踪摄像机，不行的话用左边高级的详细分析\n\nPR将文件转为avi，视频编码器为Intel IYUV编码解码器，导入MMD点击省性能\n\n解析好后选择地面区块，设置地平面和原点，添加镜头和文本\n\n选中摄像机，文件-脚本-运行实景合成脚本调整好场景大小导出（记得先再编辑-首选项-脚本和表达式里勾选允许脚本写入文件）\n\n先将工具包里的fx放入材质文件夹，再拖入pmx，下面调整off\n\n给插件上材质，打开插件调整阴影位置\n\n之后用ray渲染，拖入人物，天空盒选用Sky Hemisphere\n\nfastTop+ focalLength- EnvDiffLight 0.01 EnvSSSL+ EnvSpecLight(镜反射)- bottomV-\n\nSunlight- shadowV- Contrast-\n\nPSM里把插件消去，SSAO改为100\n\n导出绿幕视频，拖到pr，aep文件也拖入pr\n\npr右侧效果找到视屏效果-键控-超级键，主要颜色选中绿布，有绿布可以降低阴影\n\n\n流程2.0\n载入ray和water（在材质&gt;可编程&gt;水）和平行光\n加入skyBox，调整顺序\n上天空盒材质，main材质\n添加预设控制器数据\n把water的main和材质关掉\n加入模型，显示轮廓线大小最小\n人物main中毛发改为最长的main\n人物材质上Toon下的material02\n将平行光的lightMap改为最后一个，有阴影\n材质skin默认，face中，eye弱\n加入AL大小0.3\n绘制顺序：\n天空盒-timeofday-模型-MME-controller\n\n\n\n","categories":["Tech"],"tags":["MMD"]},{"title":"MMD流程迭代","url":"/2025/08/17/Tech/MMD/MMD%E6%B5%81%E7%A8%8B%E8%BF%AD%E4%BB%A3/","content":"背景随着各种MMD工具的更新，插件的出现，制作MMD有了更多选择。比如从传统的MikuMikuDance到Blender、Unity和Unreal Engine等专业3D软件。\n难点和问题最大的问题其实是数据格式，在MMD软件中，模型文件是pmx格式，而动作和相机数据都是vmd。\nPMX作为MMD模型的专有格式，虽然在MMD生态系统中被广泛支持，但在其他3D软件中却面临诸多问题：\n\n​材质系统差异​：PMX的材质表达与主流PBR材质工作流不兼容\n​骨骼权重限制​：某些复杂蒙皮效果在其他引擎中难以完美重现\n​物理系统​：MMD特有的物理模拟在其他平台需要重新实现\n\nVMD格式虽然小巧高效，但也存在跨平台问题：\n\n​时间轴精度​：不同软件对帧率的处理方式不同\n​曲线插值​：动作曲线在不同引擎中的表现可能不一致\n​相机动画​：MMD相机参数与其他3D软件的映射问题\n\n解决方案\n​PMX转通用格式​：\n使用Blender的MMD Tools插件转换为fbx&#x2F;gltf\nCATS插件提供的优化和重定向功能\n\n\n​VMD动作处理​：\nMMD4Mecanim等Unity插件提供的重定向解决方案\n在Blender中烘焙到一个物体\n\n\n​VMD相机运动处理​：\n使用MMD Tools导入VMD相机数据，会生成一个带有关键帧的空对象和MMD相机，将它烘焙并到处\n\n\n\n新MMD流程Blender\n在Blender上我们可以用鸣潮二创也能如此简单🤨？！！【鸣潮二创教程&#x2F;偏新手】哔哩哔哩_bilibili这篇教程提供的整合包。（由于鸣潮二创也基本上就是MMD制作的流程，所以这篇教程大概够了。\n\n我再精简一下这个视频的内容：\n\n下载好这个定制版blender之后，导入启用三个插件\nmmd-tool\nMiku_Miku_Rig2.0 (AAAMi)\nmmr补充4.1 (鬼离果)\n\n\n然后进行简单的设置（为了适应预设效果）\n使用合成器\n打开后处理\n修改色彩方案\n视图降噪关了\n\n\n然后追加内容，先导入NodeTree里的Bloom，再导入Collections的模型\n用mmd-tool处理\n合成器里面加入Bloom节点\n用MMR生成控制器\n用MMR补充插件删除多余部分\n\n\n然后去时间轴用i插入关键帧k动画或者mmd-tool导入动画\nmmd-tool生成物理以及烘焙物理\n可以调整内容\n修改边缘光光照颜色和强度\n显示修改器效果\n帧率和关键帧距离都放大\n\n\n\nmmd-tools使用注意\n导入动作可以设定间距，但是必须当前帧是1。而比如间隔10帧，则第11帧的动作开始有效。\n\n换头手术\n首先用MMD-tools将模型的头骨切开，删除不要的部分，注意刚体啥的也要一块删\n\n保留需要换的头的一部分脖子用于过渡\n\n将头和脖子合并，并且定点也要合并（按距离）\n\n然后解锁骨骼的移动权限，将头调整到合适位置\n\n然后姿态模式下将两个骨头缝合\n\n测试一下如果没有联动，就是父子级设置错了，要后选父级，可以去编辑模式改\n\n换头后端动画问题：\n\n如果看不到关键帧，就去动画时间线把报错取消掉\nblender种骨骼姿态也可以应用为形态键\n所以有时候形态键冲突导致新头没有表情，可以通过mmdtools里的变形工具选项将形态键应用为.placeholder，这样就有了完整的形态键，可以去看动作文件把需要用于表情的锁定，然后删除其他的。一般，头上的会自动重命名加个2，（其实合并之前应该先一键删除无用形态键）\n\n\n\n\n\n\n增加细节\n按距离合并定点\n重置矢量 (Alt + M 或者 编辑模式去网格里面找矢量选项）\n去面里面找 三角面-&gt;四边面 （选择90°，比较UV）\n再加细分修改器，矫正平滑修改器\n\n贴花给人物装上配饰有几种方法：\n\n先选择身体再选择配饰，进入刷权重界面，进行权重传递，合并网格前需要保证UVMap名字一样（网格需要在骨骼下面？）\n通过表面形变修改器吸取物体，点击绑定但是不要应用\n\n布料模拟布料模拟，建议素体以角色为基础，然后导出素体abc时只选择你要模拟的部位，因为摇晃等不确定因素可能导致素体和角色动作不相同从而造成衣服严重穿模，同时只有一个角色也便于添加物理\n删掉手臂烘焙动骨动画，导出仅选择，为abc\n导入MD的时候单位mm缩放是125000%\n解算完选中服装板片导出pc2\n导入blender obj文件缩放0.0008\n添加网格缓存修改器并添加数据\n打光和输出配置可以创建多个立方体做体积雾（原理化体积）需要把世界环境的雾生成范围改一下为了速度快一点，可以把渲染的采样数量降低，光阈值提高可以把效果设置为电影感，同时改为高对比度伽马值适当调低\n渲染之前检查一下表情有没有应用\nUnity依赖Blender先在Blender导出FBX格式的数据：\n\n选择要导出的模型和骨骼系统\n点击”文件”-&gt;”导出”-&gt;”FBX”\n在导出设置中配置以下关键选项：\n勾选”仅导出选中对象”\n包含物体类型选择”Mesh”和”Armature”\n几何数据中确保包含法线和UV\n如果包含动画，勾选”烘焙动画”\n\n\n将FBX文件和贴图拖入Unity项目Assets文件夹\n选中FBX文件，在Inspector中进行以下设置：\n动画类型设置为”Humanoid”（人形骨骼）\n配置骨骼映射关系\n设置材质和贴图\n\n\n\nPS： 以上操作其实一般不用于Unity，因为Unity的动作模型动作导入用MMD4UnityTools插件更加便捷和准确，Blender导出镜头部分则主要在Unreal那边统一讲解。\n不依赖Blender主要使用MMD4UnityTools工具集，安装插件后将需要转化的文件拖入到资源文件夹即可进行进一步操作。我之前也编写过一个 自动取出主贴图来适应Unity新渲染管线的插件\nUnreal依赖Blender\n同样有使用Blender和不使用Blender的方法，使用的话和Unity类似，但是要注意单位和导出的问题\n\n人物模型部分\nBlender\n安装MMD Tools插件\n把帧率改一下，缩放单位改为0.01\nMMD Tools导入PMX并把缩放改为8 （如果要保持和VRM4U导入骨骼一致用兼容骨架，可以取消勾选将骨骼重命名，兼容骨架需要手动在虚幻骨架窗口中 window -&gt; asset detail 来打开资产详情）\n不选中rigidbody和joints层级，仅导出可见项，记得骨骼可见（VRM4U导出的不包含rigidbody，从mesh开始的，所以可以只选中这一层级）\n按照UE骨骼标准调整骨骼父级关系\n同时选中模型和骨骼导出为FBX\n路径模式选择”复制”并内嵌纹理（如果还是没有贴图，那就取消自动打包资源再试试。。如果还不行，可能是shader节点不支持FBX，比如没有用BSDF，可以选中mesh然后点击convert to blender）\n设置平滑选择为面\n取消勾选”添加叶骨”\n\n\nUE\n提前创建masked类型材质并用变量赋予有rbga的black贴图，rgb a分别连到颜色和透明度及mask\n导入时勾选高级里的Vertex Attributes\n选择法线和切线\n选择实例化材质，并且赋予base texture给基础和不透明度\n\n\n\n动作部分\n需要接着人物模型部分操作\n选中角色骨骼导入动作，缩放改为8\n将动作赋予给人物后，可以启用物理和烘焙，导出的时候只选择骨骼和烘焙动画，如果需要表情，需要导出网格体\n\n相机部分\nBlender\n单位改为0.01，选中相机，导入相机动作缩放为8\n导出.usdc （通用场景描述）\n勾选动画以及注意使用英文路径和名称\n\n\nUE\n启用USD导入插件\n角色设置到原点\nfile -&gt; import into level 导入 usdc文件\n找到资源视图里的关卡序列，并添加Camera Cut Track 选择为 Camera\n然后把角色和动作导入进去\n播放\n\n\n\nVRM4U插件\n启用插件后要在项目设置里面拉高他们的导入优先权\n\n使用VRM4U插件导入PMX：\n\n材质类型选择MToon Unlit\nscale 0.08\n生成描边\n勾选部分Optimize选项\n如果要启用描边，导入后把 Plugins&#x2F;VRM4U Content&#x2F;Util&#x2F;Actor&#x2F;MToonAttachActor 拖到人物位置，并且在细节面板选择人物。要改参数可以去人物AssetList里面找Outline材质\n\n使用IVP5U导入VMD：有可能出现重定向问题，可以重新设置重定向animation，不建议\n启用物理\n主要分为从Blender，Unity，UE三个方面\n\n\nBlender中用mmd-tool，注意要在人物移动到开始跳舞的位置再点击物理，然后再点击烘焙，通知注意播放模式是播放每一帧（这是因为Blender的物理计算是依靠刚体，从第一帧开始顺序计算的，不是实时模拟）\n\n可以用spring bones插件去模拟欧派运动，通过选择姿态模式骨骼应用之后开始模拟，然后再烘焙动作。\n\n以下内容为Blender物理指南，作者MiaoBox  1.开启物理  2.开启物理后有两个参数，一般用默认的就行  3.游标拖到0帧（一般第1帧也行）  4.点下更新世界，改子步数：1，迭代：60  5.设置下结束帧，设置多长物理就烘培到哪，如果不小心烘焙太长，按esc取消  6.看下是不是在“播放每帧”，烘培需要每帧  7.烘培，完成\n  雷区1：没有烘培好就去拖动关键帧  雷区2：动作幅度太大  雷区3：烘培的起始帧不是0或1\n  建议1：  遇到模型物理一直错误，可能模型的问题，换模型试  建议2：  第一帧静止姿态，这也是为什么导入的动作第一帧是静止的，隔几帧之后才是动作开始\n\nUnity中就是用Magica插件啥的，具体有点忘了\n\nUE用Kawaii插件\n\n\n输出结果启用插件movie render queue就可以在sequencer上找到渲染视频的按钮，可以增加几个设置选项，比如输出改为PNG。导出后的图片序列可以用AE进行处理。\n解惑\n为什么要改变缩放单位，导入时还要进行缩放？\n\n\n改变单位，是为了方便导出到其他软件\n因为软件只认数值而不认单位\nBlender使用的是m，而UE使用的是cm\n所以缩放改为0.01即可\n导入模型要放大100倍是为了适应现在缩放后的单位\n否则角色导入进去就太小了\n\n\n为什么要将路径改为复制并内嵌材质，材质转为Blender？\n\n\n路径改为复制是为了让材质贴图在其他机器其他路径也能显示\n内嵌材质是因为fbx格式模型可以内嵌材质（如果是obj格式就得关闭自动打包资源，改为手动解包，因为blender格式可以内嵌资源，而obj格式不行）\n材质转为blender的BSDF才能适配fbx导出时的材质数据，否则一些奇奇怪怪只有blender有的高级功能节点，无法自动转化为fbx的材质，就会导致丢失材质\n\n","categories":["Tech"],"tags":["MMD"]},{"title":"计算机视觉-兴军亮","url":"/2025/11/22/Course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/","content":"计算机视觉基础(第2讲)梯度下降法： 梯度下降法是一种通过迭代方式寻找函数最小值的优化算法，其核心在于沿着目标函数梯度的反方向逐步调整参数。公式： $\\theta_{n+1} &#x3D; \\theta_n - \\alpha \\cdot J’(\\theta_n)$每一个分量的偏导数执行这个梯度下降公式。\n最小二乘法： 通过最小化误差平方和来寻找数据最佳函数匹配的数学优化技术。损失函数：$L(\\beta_0, \\beta_1) &#x3D; \\sum_{i&#x3D;1}^{n} (y_i - \\hat{y}i)^2 &#x3D; \\sum{i&#x3D;1}^{n} \\big( y_i - (\\beta_0 + \\beta_1 x_i) \\big)^2$，一元线性回归有解析解，$y&#x3D;β_0​+β_1​x$，最优参数为：$\\beta_1 &#x3D; \\frac{\\sum_{i&#x3D;1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i&#x3D;1}^n (x_i - \\bar{x})^2}, \\quad \\beta_0 &#x3D; \\bar{y} - \\beta_1 \\bar{x}$，其中其中$\\bar{x},\\bar{y}$是样本均值。\n信息熵： 对于一个离散随机变量 X，其可能取值为 x1​,x2​,…,xn​，对应的概率为 P(xi​)，则香农熵为$H(X) &#x3D; -\\sum_{i&#x3D;1}^{n} P(x_i) \\log_2 P(x_i)$，交叉熵为$H(p, q) &#x3D; -\\sum_{i&#x3D;1}^{n} p(x_i) \\log q(x_i)$，其中$x_i$为离散随机变量（标签）的取值。\n傅里叶变换： 是一种将信号从时域（或空域）转换到频域的数学工具，其核心思想是将任意复杂信号分解为一系列不同频率的正弦波（或复指数）的叠加。\n模式识别主要分类：\n\n贝叶斯决策: 最小错误率贝叶斯决策，最小风险贝叶斯决策；模式识别效果的度量等\n概率密度函数估计: 最大似然估计、贝叶斯估计、非参数估计等\n特征提取选择及降维: 特征距离度量、特征选择算法、特征选择度量、主成分分析、KL变换等\n概率图模型: 无向图（马尔可夫网），有向图（贝叶斯网络、隐马尔可夫网络HMM）等\n线性和非线性分类器: ​ LDA、Perception、LR、SVM；分段线性分类器、二次判别函数、MLP、Kernel SVM等\n非参数与集成学习: 近邻法、决策树、随机森林、Bagging、Boosting\n非监督学习与聚类: ​ 基于模型的聚类、混合模型、动态聚类、模糊聚类、分级聚类、自组织映射神经网络、一致聚类\n模式识别系统的评价: ​ 监督模式识别的错误率估计、有限样本下错误率的区间估计、非监督模式识别的性能评价等\n\n贝叶斯决策：贝叶斯决策是统计模式识别中的核心理论框架，基于贝叶斯定理，在已知先验概率和类条件概率的情况下，通过计算后验概率来最小化分类错误率或期望风险。\n1. 贝叶斯定理公式$P(\\omega_i | \\mathbf{x}) &#x3D; \\frac{P(\\mathbf{x} | \\omega_i) P(\\omega_i)}{P(\\mathbf{x})}$其中：\n\n$P(\\omega_i | \\mathbf{x})$：后验概率（观测到特征$\\mathbf{x}$后，样本属于类别$\\omega_i$的概率）\n$P(\\mathbf{x} | \\omega_i)$：类条件概率（在类别$\\omega_i$下出现特征$\\mathbf{x}$的概率）\n$P(\\omega_i)$：先验概率（类别$\\omega_i$出现的初始概率）\n$P(\\mathbf{x}) &#x3D; \\sum_{j&#x3D;1}^{c} P(\\mathbf{x} | \\omega_j) P(\\omega_j)$：证据因子（归一化常数）\n\n2. 最小错误率贝叶斯决策规则$\\text{若 } P(\\omega_i | \\mathbf{x}) &#x3D; \\max_{j&#x3D;1,2,\\cdots,c} P(\\omega_j | \\mathbf{x}) \\text{，则决策 } \\mathbf{x} \\in \\omega_i$等价形式（常用）：$\\text{若 } P(\\mathbf{x} | \\omega_i) P(\\omega_i) &gt; P(\\mathbf{x} | \\omega_j) P(\\omega_j) \\quad \\text{对所有 } j \\neq i \\text{，则决策 } \\mathbf{x} \\in \\omega_i$\n3. 最小风险贝叶斯决策规则$\\text{若 } R(\\alpha_i | \\mathbf{x}) &#x3D; \\min_{j&#x3D;1,2,\\cdots,c} R(\\alpha_j | \\mathbf{x}) \\text{，则采取决策 } \\alpha_i$其中条件风险：$R(\\alpha_i | \\mathbf{x}) &#x3D; \\sum_{j&#x3D;1}^{c} \\lambda(\\alpha_i, \\omega_j) P(\\omega_j | \\mathbf{x})$，其中$\\lambda(\\alpha_i, \\omega_j)$表示将真实类别$\\omega_j$的样本误判为$\\omega_i$的损失函数。\n特征提取及度量： 特征提取是将原始数据转换为更易于处理的形式的过程，通常涉及到降维、特征选择和特征变换等步骤。特征度量则是对提取到的特征进行评估和比较的过程，常用的度量方法包括欧氏距离、曼哈顿距离、余弦相似度等。\n1. 特征提取方法\n\n主成分分析（PCA）：通过线性变换将数据投影到方差最大的方向上，实现降维和去相关。\n线性判别分析（LDA）：通过最大化类间散度与类内散度的比值来寻找最佳投影方向。\n独立成分分析（ICA）：将多变量信号分解为统计独立的成分，常用于盲源分离。\n小波变换：通过多尺度分析提取信号的局部特征，适用于图像处理和信号分析。\n\n2. 特征度量方法\n\n欧氏距离：衡量两个特征向量之间的直线距离，适用于连续型特征。\n曼哈顿距离：计算两个特征向量在各维度上的绝对差值之和，适用于离散型特征。\n余弦相似度：通过计算两个特征向量的夹角余弦值来衡量相似性，适用于文本和高维数据。(公式：$ \\text{Cosine Similarity} &#x3D; \\frac{A \\cdot B}{|A| |B|} $)\n马氏距离：考虑特征之间的相关性，适用于多变量数据的度量。 (公式：$ D_M(x, y) &#x3D; \\sqrt{(x - y)^T S^{-1} (x - y)} $，其中$S$为协方差矩阵)\n\n机器学习不同问题及对应的典型计算机视觉任务：\n\n监督学习：是机器学习最常见的一种算法学习训练方式。它使用标记数据集来训练算法，以便训练后的算法可以对数据进行分类或准确预测结果。典型任务包括图像分类、目标检测、语音识别等。\n无监督学习：指的是用算法来分析并聚类未标记的数据集，以便发现数据中隐藏的模式和规律，而不需要人工干预。 典型任务包括聚类分析、降维、异常检测等。无监督学习更适合处理大量的数据。\n强化学习：是一种机器学习技术，它基于反馈的学习方法，对算法执行的正确和不正确行为分别进行奖励 和惩罚的制度，目的是使算法获得最大的累积奖励，从而学会在特定环境下做出最佳决策。 典型任务包括游戏AI、机器人控制、自动驾驶等。\n半监督学习：或可称为混合学习，可以说是两全其美的方式。在我们拥有相对较少的标记数据和大量未标记数据的情况下，半监督学习结合了监督学习和无监督学习的优势，可以发挥很好的作用。典型任务包括文本分类、图像识别等。\n自监督学习: 不需要人工标注训练数据，它的模型主要训练从大规模的无监督数据中挖掘能够应用于自身的监督信息，从而从输入的一部分数据中去学习另一部分。典型任务包括自然语言处理、计算机视觉等。\n\n典型的深度学习网络结构：\n\n前馈神经网络：包括全连接层、卷积层、池化层等，用于处理图像、语音等数据。\n卷积神经网络：一种前馈神经网络，专门用于处理图像数据，通过卷积层、池化层和全连接层等结构提取图像特征，实现图像分类、目标检测等任务。\n循环神经网络：一种前馈神经网络，用于处理序列数据，如文本、语音等，通过循环结构捕捉序列中的时间依赖关系。\n长短时记忆网络：一种特殊的循环神经网络，能够有效地捕捉长距离依赖关系，广泛应用于自然语言处理、语音识别等任务。\n注意力机制网络：通过引入注意力机制，能够动态地关注输入数据的不同部分，提高模型的表达能力和性能，广泛应用于自然语言处理、计算机视觉等领域。\n\n图像的形成(第3讲)人眼成像的基本原理： 人眼通过角膜和晶状体将光线聚焦在视网膜上，视网膜上的感光细胞将光信号转换为电信号，传递给大脑进行处理和解释。\n双视几何：双视几何是研究两个摄像机视角下同一场景的几何关系的学科，主要涉及摄像机模型、投影变换、立体匹配等内容。其核心概念包括基础矩阵、极线约束和三角测量等。\n\n基础矩阵（Fundamental Matrix）：描述两个摄像机视图之间的对应关系，满足极线约束条件。\n极线约束（Epipolar Constraint）：在双视几何中，图像点在一个视图中的位置决定了其在另一个视图中的对应极线位置。\n三角测量（Triangulation）：通过两个摄像机视图中的对应点，利用几何关系计算三维空间中点的位置。\n\n常见的几何仿射变换：包括平移、旋转、缩放、剪切等变换，这些变换可以通过矩阵运算来表示和实现。\n\n平移变换：将图像中的点沿某个方向移动一定距离。矩阵表示为：$\\begin{bmatrix}1 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; t_y \\ 0 &amp; 0 &amp; 1\\end{bmatrix}$\n旋转变换：将图像中的点绕某个中心点旋转一定角度。矩阵表示为：$\\begin{bmatrix}\\cos\\theta &amp; -\\sin\\theta &amp; 0 \\ \\sin\\theta &amp; \\cos\\theta &amp; 0 \\ 0 &amp; 0 &amp; 1\\end{bmatrix}$\n缩放变换：将图像中的点沿某个方向缩放一定比例。矩阵表示为：$\\begin{bmatrix}s_x &amp; 0 &amp; 0 \\ 0 &amp; s_y &amp; 0 \\ 0 &amp; 0 &amp; 1\\end{bmatrix}$\n剪切变换：将图像中的点沿某个方向进行倾斜变换。矩阵表示为：$\\begin{bmatrix}1 &amp; k_x &amp; 0 \\ k_y &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\\end{bmatrix}$\n\n光照模型：光照模型用于描述光线与物体表面相互作用的方式，常见的光照模型包括朗伯反射模型、冯氏反射模型和镜面反射模型等。\n\n朗伯反射模型：描述理想漫反射表面，光线均匀地反射到所有方向。公式为：$L &#x3D; k_d I \\max(0, \\cos\\theta)$，其中$k_d$为漫反射系数，$I$为入射光强度，$\\theta$为入射光与表面法线的夹角。\n冯氏反射模型：描述具有一定光泽的表面，结合了漫反射和镜面反射。公式为：$L &#x3D; k_d I \\max(0, \\cos\\theta) + k_s I \\max(0, \\cos\\alpha)^n$，其中$k_s$为镜面反射系数，$\\alpha$为视角与反射方向的夹角，$n$为高光指数。\n\n摄像机的成像过程和主要参数：摄像机通过镜头将光线聚焦在图像传感器上，形成数字图像。主要参数包括焦距、光圈、快门速度、ISO感光度等，这些参数影响图像的曝光、清晰度和噪声水平。\n\n焦距：镜头到图像传感器平面的距离，决定了摄像机的视角范围。\n光圈：镜头中控制光线进入的孔径大小，影响图像的景深和光圈值。\n快门速度：控制光线进入图像传感器的时间，影响图像的曝光时间。\nISO感光度：衡量图像传感器的敏感度，影响图像的噪声水平。\n\n常见的图像和视频格式：包括JPEG、PNG、BMP、GIF、AVI、MP4等，这些格式有不同的压缩方式、颜色深度和用途。\n\nJPEG：有损压缩格式，适用于静态图像，支持高压缩比。\nPNG：无损压缩格式，适用于静态图像，支持透明度。\nBMP：无损压缩格式，适用于静态图像，支持高分辨率和颜色深度。\nGIF：有损压缩格式，适用于动画图像，支持256色和透明度。\nAVI：视频容器格式，支持多种编码方式，适用于高质量视频\nMP4：视频容器格式，支持高压缩比和多种编码方式，适用于流媒体传输。\nMKV：视频容器格式，支持多种编码方式和字幕，适用于高质量视频存储。\n\n底层视觉1:图像处理(第4讲)图像的亮度：像素值的强度，通常表示为灰度值或RGB值。亮度可以通过加权平均法计算，例如：$Y &#x3D; 0.299R + 0.587G + 0.114B$。图像的对比度：图像中像素值的变化范围，通常通过计算图像的标准差或方差来衡量。对比度较高的图像具有较大的像素值变化范围，而对比度较低的图像则像素值变化较小。公式：$C &#x3D; \\frac{I_{max} - I_{min}}{I_{max} + I_{min}}$，其中$I_{max}$和$I_{min}$分别为图像的最大和最小像素值。颜色空间与变换公式：常见的颜色空间包括RGB、HSV、Lab等。颜色空间变换公式如下：\n\nRGB到HSV变换：公式为$H &#x3D; \\begin{cases} 0, &amp; \\text{if } C_{max} &#x3D; C_{min} \\ 60 \\times \\frac{G - B}{C_{max} - C_{min}} + 360, &amp; \\text{if } C_{max} &#x3D; R \\ 60 \\times \\frac{B - R}{C_{max} - C_{min}} + 120, &amp; \\text{if } C_{max} &#x3D; G \\ 60 \\times \\frac{R - G}{C_{max} - C_{min}} + 240, &amp; \\text{if } C_{max} &#x3D; B \\end{cases}$，$S &#x3D; \\begin{cases} 0, &amp; \\text{if } C_{max} &#x3D; 0 \\ \\frac{C_{max} - C_{min}}{C_{max}}, &amp; \\text{otherwise} \\end{cases}$，$V &#x3D; C_{max}$，其中$C_{max}$和$C_{min}$分别为RGB中的最大值和最小值。\n\n举例：R &#x3D; 255, G &#x3D; 0, B &#x3D; 0，先将RGB归一化为(1,0,0)，则$C_{max} &#x3D; 1, C_{min} &#x3D; 0$，计算得$H &#x3D; 0, S &#x3D; 1, V &#x3D; 1$，即HSV为(0, 1, 1)。（H取值范围为0-360度，S和V取值范围为0-1。）\n\nHSV到RGB变换：公式为$R &#x3D; C \\times \\max(0, \\cos(\\frac{\\theta}{60} - 1)) + M$，$G &#x3D; C \\times \\max(0, -\\cos(\\frac{\\theta}{60} + 1)) + M$，$B &#x3D; C \\times \\max(0, \\cos(\\frac{\\theta}{60} + 3)) + M$，其中$C &#x3D; V \\times S$，$M &#x3D; V \\times (1 - S)$，$\\theta$为H的值。\n\n直方图均衡化：通过调整图像的灰度分布来增强图像对比度的方法。步骤包括计算图像的累积分布函数（CDF），然后使用CDF对原始图像进行映射。公式：$s_k &#x3D; (L - 1) \\cdot \\sum_{j&#x3D;0}^{k} \\frac{n_j}{N}$，其中$s_k$为均衡化后的像素值，$L$为灰度级数，$n_j$为灰度级$j$的像素数，$N$为图像总像素数。\n举例：假设一幅图像的灰度级为0-3，像素值分布为[0, 0, 1, 1, 2, 3]，则灰度级0的像素数为2，灰度级1的像素数为2，灰度级2的像素数为1，灰度级3的像素数为1，总像素数N&#x3D;6。计算累积分布函数（CDF）（其中像素个数依次累加，标准理论公式）：\n\nCDF(0) &#x3D; 2&#x2F;6 &#x3D; 0.333\nCDF(1) &#x3D; (2+2)&#x2F;6 &#x3D; 0.666\nCDF(2) &#x3D; (2+2+1)&#x2F;6 &#x3D; 0.833\nCDF(3) &#x3D; (2+2+1+1)&#x2F;6 &#x3D; 1.0\n\n然后使用CDF进行映射，得到均衡化后的像素值（取整方法为四舍五入）：\n\ns(0) &#x3D; (4-1) * 0.333 &#x3D; 1\ns(1) &#x3D; (4-1) * 0.666 &#x3D; 2\ns(2) &#x3D; (4-1) * 0.833 &#x3D; 2\ns(3) &#x3D; (4-1) * 1.0 &#x3D; 3\n\n均衡化后的图像像素值为[1, 1, 2, 2, 2, 3]。\n滤波：用于去除图像噪声和平滑图像的技术。常见的滤波方法包括：\n\n区域线性滤波：通过卷积操作实现图像平滑，如均值滤波和高斯滤波。均值滤波卷积核示例：$\\begin{bmatrix} \\frac{1}{9} &amp; \\frac{1}{9} &amp; \\frac{1}{9} \\ \\frac{1}{9} &amp; \\frac{1}{9} &amp; \\frac{1}{9} \\ \\frac{1}{9} &amp; \\frac{1}{9} &amp; \\frac{1}{9} \\end{bmatrix}$高斯滤波卷积核示例（σ&#x3D;1）：$\\begin{bmatrix} \\frac{1}{16} &amp; \\frac{2}{16} &amp; \\frac{1}{16} \\ \\frac{2}{16} &amp; \\frac{4}{16} &amp; \\frac{2}{16} \\ \\frac{1}{16} &amp; \\frac{2}{16} &amp; \\frac{1}{16} \\end{bmatrix}$，（σ&#x3D;标准差，决定模糊程度）\n可分离滤波：将二维滤波器分解为两个一维滤波器，提高计算效率。例如：高斯滤波器可以分解为水平和垂直方向的一维滤波器：水平滤波器：$\\begin{bmatrix} \\frac{1}{4} &amp; \\frac{1}{2} &amp; \\frac{1}{4} \\end{bmatrix}$垂直滤波器T：$\\begin{bmatrix} \\frac{1}{4} &amp; \\frac{1}{2} &amp; \\frac{1}{4} \\end{bmatrix}^T$\n带通可控滤波：允许通过特定频率范围的滤波器。（适用于频域处理）\n中值滤波：通过替换像素值为邻域内像素的中值来去除噪声。（适用于椒盐噪声）\n双边滤波：同时考虑空间距离和像素值差异，实现边缘保留的平滑。（适用于去噪，特点是保留边缘）\n图像引导滤波：利用引导图像的信息对输入图像进行平滑处理，保留边缘细节。（适用于图像增强和去噪）\nlaplacian滤波：通过计算图像的二阶导数来增强图像边缘。（适用于边缘检测）(例如：$\\begin{bmatrix} 0 &amp; -1 &amp; 0 \\ -1 &amp; 4 &amp; -1 \\ 0 &amp; -1 &amp; 0 \\end{bmatrix}$)\n拉普拉斯金字塔：通过多次对图像进行高斯滤波和拉普拉斯滤波，得到不同尺度的图像金字塔。（适用于图像分割和特征提取、特征融合）\n高斯金字塔：通过多次对图像进行高斯滤波，得到不同尺度的图像金字塔。（适用于图像分割和特征提取）\nLoG滤波：通过计算图像的拉普拉斯高斯函数来增强图像边缘。（适用于边缘检测）\nCanny边缘检测：通过计算图像的梯度方向和幅值，并结合非极大值抑制和双阈值检测来提取图像边缘。（适用于边缘检测）（卷积核示例：Sobel算子）：$\\begin{bmatrix} -1 &amp; 0 &amp; 1 \\ -2 &amp; 0 &amp; 2 \\ -1 &amp; 0 &amp; 1 \\end{bmatrix}$\n\n二值形态学变换：用于处理二值图像的形态学操作，包括膨胀、腐蚀、开运算（先腐蚀后膨胀）、闭运算（先膨胀后腐蚀）等。\n小波变换：一种时频分析方法，通过多尺度分解提取图像特征，常用于图像压缩和去噪。计算题：对一维信号进行离散小波变换（DWT），假设信号为[4, 6, 10, 12]，使用Haar小波进行变换。步骤如下：\n\n计算平均值和差值：\n\n\n平均值：[(4+6)&#x2F;2, (10+12)&#x2F;2] &#x3D; [5, 11]\n差值：[(4-6)&#x2F;2, (10-12)&#x2F;2] &#x3D; [-1, -1]\n\n\n结果为：[5, 11, -1, -1]，其中前两个值为低频分量，后两个值为高频分量。变换后相当于信号被分解为低频和高频部分，便于后续处理。\n\n底层视觉2:模型拟合(第5讲)插值模型：用于估计图像中未知像素值的方法。常见的插值方法包括最近邻插值、双线性插值、双三次插值等。\n\n最近邻插值：使用最接近的已知像素值进行插值。\n双线性插值：使用四个最近邻像素值进行插值。\n双三次插值：使用16个最近邻像素值进行插值，通常使用三次多项式进行插值。\n\n常用径向基函数：径向基函数（RBF）是一种用于函数逼近和插值的数学工具，常见的RBF包括高斯函数、多项式函数和薄板样条函数等。\n\n高斯函数：$ \\phi(r) &#x3D; e^{-(\\epsilon r)^2} $，其中$r$为距离，$\\epsilon$为形状参数。\n多项式函数：$ \\phi(r) &#x3D; r^k $，其中$k$为多项式的阶数。\n薄板样条函数：$ \\phi(r) &#x3D; r^2 \\log(r) $，适用于二维插值问题。使用方法：给定一组数据点，通过RBF构建插值函数，实现对未知点的估计。例如，使用高斯函数对一组数据点进行插值，可以构建一个高斯函数，使得该函数在已知数据点处取值为数据点的值，在未知点处取值为估计值。\n\n能量最小化方法：通过定义能量函数并最小化该函数来实现图像处理任务的方法。常见的能量最小化方法包括变分法和马尔可夫随机场（MRF）模型等。薄板样条也可用于能量最小化，通过最小化曲率能量实现平滑插值，\n变分方法、总变差：变分方法是一种通过优化能量函数来求解图像处理问题的数学工具。总变差（Total Variation, TV）是一种常用的能量函数，用于图像去噪和恢复。TV能量函数定义为：$E(u) &#x3D; \\int |\\nabla u| , dx$其中$u$为图像函数，$\\nabla u$为图像的梯度。通过最小化TV能量函数，可以实现图像的平滑处理，同时保留边缘信息。\n马尔可夫随机场（MRF）模型：马尔可夫随机场是一种用于描述图像中像素间关系的概率图模型。MRF模型可以用于图像分割、图像去噪等任务。MRF模型通常由一组像素和一组像素间的依赖关系组成，通过定义像素的局部邻域和像素间的转移概率，实现对图像的建模和优化。例如，在图像分割任务中，MRF模型可以用于描述像素间的相似性和边界信息，通过优化能量函数实现对图像的分割。\n底层视觉3:运动估计(第6讲)鲁棒误差估计算子：用于处理含有异常值的数据，通过降低异常值对估计结果的影响，提高估计的鲁棒性。常见的鲁棒误差估计算子包括Huber损失函数、Tukey损失函数等。\n\nHuber损失函数：对于小误差使用平方损失，对于大误差使用线性损失。公式为：$L_{\\delta}(r) &#x3D; \\begin{cases} \\frac{1}{2} r^2, &amp; \\text{if } |r| \\leq \\delta \\ \\delta (|r| - \\frac{1}{2} \\delta), &amp; \\text{if } |r| &gt; \\delta \\end{cases}$\nTukey损失函数：对于小误差使用平方损失，对于大误差使用截断损失。公式为：$L(r) &#x3D; \\begin{cases} \\frac{1}{2} r^2, &amp; \\text{if } |r| \\leq \\delta \\ \\delta (|r| - \\frac{1}{2} \\delta), &amp; \\text{if } |r| &gt; \\delta \\end{cases}$其中$r$为估计误差，$\\delta$为截断阈值。\n\n光流！Lucas-Kanade算法：一种基于光流约束方程的局部运动估计算法，通过最小化图像亮度变化的平方误差来估计像素的运动矢量。算法步骤包括：\n\n计算图像梯度：计算图像在x和y方向的梯度。（例如图像卷积Sobel算子）\n构建光流约束方程：基于图像亮度不变性假设，建立光流约束方程。\n求解运动矢量：通过最小化光流约束方程的平方误差，求解运动矢量。步骤详解：\n在每个像素点的邻域内，构建光流约束方程的矩阵形式：$\\begin{bmatrix} I_x &amp; I_y \\end{bmatrix} \\begin{bmatrix} u \\ v \\end{bmatrix} &#x3D; -I_t$\n通过最小二乘法求解上述方程，得到运动矢量$(u, v)$。\n\n\n\n例题：假设在某个像素点处，图像梯度为$I_x &#x3D; 2, I_y &#x3D; 3, I_t &#x3D; -1$，则光流约束方程为：$2u + 3v &#x3D; 1$通过最小二乘法求解，得到运动矢量$(u, v)$。具体计算如下：\n\n构建矩阵形式：$\\begin{bmatrix} 2 &amp; 3 \\end{bmatrix} \\begin{bmatrix} u \\ v \\end{bmatrix} &#x3D; 1$\n通过最小二乘法求解，得到：$u &#x3D; \\frac{3}{13}, v &#x3D; \\frac{2}{13}$\n\n仿射运动模型：一种描述图像中物体运动的数学模型，假设物体的运动可以通过仿射变换来表示。仿射运动模型包括平移、旋转、缩放和剪切等变换。仿射变换的数学表示为：$\\begin{bmatrix} x’ \\ y’ \\end{bmatrix} &#x3D; \\begin{bmatrix} a_{11} &amp; a_{12} \\ a_{21} &amp; a_{22} \\end{bmatrix} \\begin{bmatrix} x \\ y \\end{bmatrix} + \\begin{bmatrix} t_x \\ t_y \\end{bmatrix}$其中$(x, y)$为原始像素坐标，$(x’, y’)$为变换后的像素坐标，$a_{ij}$为仿射变换矩阵的元素，$t_x, t_y$为平移向量。\n光流计算公式及约束：光流是描述图像中像素运动的矢量场，常用的光流计算公式包括光流约束方程和光流平滑约束。光流约束方程基于图像亮度不变性假设，表示为：$I_x u + I_y v + I_t &#x3D; 0$其中$I_x, I_y$为图像在x和y方向的梯度，$I_t$为图像的时间梯度，$u, v$为像素的运动矢量。光流平滑约束用于保证光流场的连续性，通常通过最小化光流场的梯度来实现。\n中层视觉1:特征检测(第7讲)特征点的检测匹配：特征点检测是从图像中提取具有显著信息的点，常用的特征点检测算法包括Harris角点检测、SIFT特征点检测等。特征点匹配是将不同图像中的特征点进行对应，常用的匹配方法包括最近邻匹配、RANSAC算法等。\n\nHarris角点检测：通过计算图像梯度的协方差矩阵，检测图像中的角点。Harris角点检测包括计算图像梯度、构建协方差矩阵、计算响应函数和非极大值抑制等步骤。\nSIFT特征点检测：通过尺度空间极值检测、关键点定位、方向分配和描述符生成等步骤，提取图像中的SIFT特征点。SIFT特征点具有尺度不变性和旋转不变性，常用于图像匹配和目标识别。\n最近邻匹配：将一个图像中的特征点与另一个图像中的特征点进行匹配，选择距离最近的特征点作为匹配对。\nRANSAC算法：一种用于处理含有异常值的匹配算法，通过迭代优化，选择最佳匹配对。RANSAC算法包括随机选择样本、构建模型、验证模型、迭代优化等步骤。\n\nSIFT特征点的描述符：SIFT特征点描述符是用于描述SIFT特征点局部图像信息的向量，通常为128维。描述符通过计算特征点周围区域的梯度方向直方图来生成，具有旋转不变性和尺度不变性。描述符的计算步骤包括：\n\n计算特征点周围区域的梯度方向和幅值。（周围区域通常为16x16像素，计算每个像素的梯度方向和幅值）\n将区域划分为4x4个子区域。（每个子区域为4x4像素）\n对每个子区域计算8个方向的梯度直方图。（每个子区域的梯度方向范围为0-360度，划分为8个方向，每个方向对应45度的范围，计算每个方向上的梯度幅值总和，形成一个8维的直方图。对于每个像素，根据其梯度方向确定其所属的方向区间，然后将该像素的梯度幅值累加到对应的方向区间中，最后得到8个方向的梯度幅值总和，形成一个8维的直方图。如何计算每个像素的梯度方向和幅值：使用Sobel算子计算图像在x和y方向的梯度，公式为：$m(x,y) &#x3D; \\sqrt{I_x^2 + I_y^2}$，$\\theta(x,y) &#x3D; \\tan^{-1}(\\frac{I_y}{I_x})$，其中$I_x$和$I_y$分别为图像在x和y方向的梯度。）\n将所有子区域的直方图连接成一个128维的描述符向量。（4x4个子区域，每个子区域8维，共128维）\n\n特征点匹配的常用方法：特征点匹配是将不同图像中的特征点进行对应的方法，常用的匹配方法包括最近邻匹配、FLANN匹配等。\n\n最近邻匹配：将一个图像中的特征点与另一个图像中的特征点进行匹配，选择距离最近的特征点作为匹配对。\nFLANN匹配：一种基于快速最近邻搜索算法的特征点匹配方法，通过构建索引树和k-d树等数据结构，提高匹配速度和精度。FLANN匹配包括构建索引、搜索最近邻、匹配筛选等步骤。\n\n中层视觉2:图像分割(第8讲)OTSU算法：一种基于图像直方图的全局阈值分割方法，通过最大化类间方差来确定最佳阈值。算法步骤包括：\n\n计算图像的直方图和总像素数。（直方图表示每个灰度级出现的次数，总像素数为图像中像素的总数。）\n遍历所有可能的阈值，计算类间方差。（对于每个阈值，将图像分为两个类：前景和背景。计算前景和背景的均值和方差，类间方差为前景和背景方差的加权和。公式为：$\\sigma_b^2(t) &#x3D; w_0(t) w_1(t) [\\mu_0(t) - \\mu_1(t)]^2$其中$w_0(t)$为背景像素占总像素的比例，$w_1(t)&#x3D; 1 - w_0(t)$为前景像素占总像素的比例，$\\mu_0(t)$为背景像素的平均灰度值，$\\mu_1(t)$为前景像素的平均灰度值。）\n选择使类间方差最大的阈值作为最佳阈值。\n\n分水岭算法：一种基于图像梯度的分割方法，通过模拟水流在图像中的流动来划分区域。算法步骤包括：\n\n计算图像的梯度图。\n识别梯度图中的局部极小值作为分割种子。\n模拟水流从种子点向外扩展，直到遇到其他水流，形成分割边界。\n\nMean-Shift图像分割：一种基于密度估计的分割方法，通过迭代移动数据点到密度最大的位置来实现分割。算法步骤包括：\n\n初始化数据点和带宽参数。(带宽参数决定了邻域的大小，初始化的数据点是图像中的像素点，选取方法为随机选取或均匀分布。)\n对每个数据点，计算其邻域内的密度估计。(使用核密度估计方法计算邻域内的密度。密度的含义是指在该点附近有多少数据点聚集，表示该区域的像素值分布情况。)\n迭代移动数据点到密度最大的位置，直到收敛。(重复计算邻域内的密度估计，并更新数据点的位置，直到位置不再变化。)\n\n图割算法的最优标记准则：图割算法是一种基于图论的全局分割方法，通过最小化图割的能量函数来实现分割。常用的最优标记准则包括最小割准则、最大流准则等。\n\n最小割准则：通过最小化图割的权重和来实现分割。详细步骤包括：\n\n\n构建图模型：将图像中的像素点作为图的节点，像素间的相似性作为边的权重。\n定义能量函数：能量函数包括数据项和光滑项，数据项表示像素与标签的匹配程度，光滑项表示相邻像素间标签的一致性。公式为：$E(L) &#x3D; \\sum_{p} D_p(L_p) + \\sum_{(p,q) \\in N} V_{p,q}(L_p, L_q)$其中$L$为标签集合，$D_p(L_p)$为数据项，$V_{p,q}(L_p, L_q)$为光滑项，$N$为邻域关系。\n最小化能量函数：通过图割算法求解最小割问题，得到最优标签分配。\n\n\n最大流准则：通过最大化图中的流量来实现分割。详细步骤包括：\n\n\n构建图模型：与最小割准则相同。\n定义流量函数：流量函数表示从源节点到汇节点的最大流量。\n最大化流量函数：通过最大流算法求解最大流问题，得到最优标签分配。\n\n中层视觉3:特征配准和拼接(第9讲)最小二乘的二维配准：通过最小化配准误差的平方和来实现图像配准。配准误差定义为：$E &#x3D; \\sum_{i&#x3D;1}^{n} (x_i - x’_i)^2 + (y_i - y’_i)^2$其中$(x_i, y_i)$为原始图像中的像素坐标，$(x’_i, y’_i)$为配准后的像素坐标，$n$为像素点的数量。通过最小化$E$，可以找到最佳的配准参数。\n鲁棒最小二乘法：通过引入鲁棒误差估计算子来提高最小二乘法的鲁棒性。常见的鲁棒误差估计算子包括Huber损失函数、Tukey损失函数等。例如，使用Huber损失函数，最小二乘问题可以重新表述为：$\\min_{\\mathbf{x}} \\sum_{i&#x3D;1}^{n} L_{\\delta}(r_i)$其中$r_i$为配准误差，$L_{\\delta}$为Huber损失函数。通过最小化上述目标函数，可以得到鲁棒的最小二乘解。\n圆柱和球坐标系：用于表示三维空间中点的位置。圆柱坐标系使用径向距离$r$、角度$\\theta$和高度$z$来表示点的位置，转换公式为：$x &#x3D; r \\cos\\theta$，$y &#x3D; r \\sin\\theta$，$z &#x3D; z$。球坐标系使用径向距离$r$、极角$\\theta$和方位角$\\phi$来表示点的位置，转换公式为：$x &#x3D; r \\sin\\theta \\cos\\phi$，$y &#x3D; r \\sin\\theta \\sin\\phi$，$z &#x3D; r \\cos\\theta$。\n**光束平差法(优化目标、视差去除)**：光束平差法是一种用于三维重建和摄像机姿态估计的优化方法，通过最小化观测误差来优化三维点和摄像机参数。优化目标通常定义为：$E &#x3D; \\sum_{i&#x3D;1}^{m} \\sum_{j&#x3D;1}^{n} | p_{ij} - \\hat{p}{ij} |^2$其中$p{ij}$为观测点，$\\hat{p}_{ij}$为重建点，$m$为摄像机数量，$n$为三维点数量。视差去除通过调整摄像机参数和三维点位置来减少观测误差，实现更准确的三维重建。常见的图像混合算法：用于将多张图像无缝拼接在一起的算法。常见的图像混合算法包括线性混合、多频段混合和泊松混合等。\n\n线性混合：通过线性加权的方式将多张图像进行混合。公式为：$I(x, y) &#x3D; \\sum_{i&#x3D;1}^{N} \\alpha_i I_i(x, y)$其中$N$为图像数量，$\\alpha_i$为权重系数，$I_i(x, y)$为第$i$张图像在$(x, y)$位置的像素值。\n多频段混合：将图像分解为多个频段，分别进行混合，再重构图像。多频段混合可以保留图像的细节信息，但计算复杂度较高。原理是通过对图像进行金字塔分解（通常使用高斯金字塔和拉普拉斯金字塔，他们的区别在于高斯金字塔是低通滤波，保留了图像的整体轮廓，而拉普拉斯金字塔是高通滤波，保留了图像的细节信息），分别对不同频段进行混合，最后将混合后的频段重构为最终图像。\n泊松混合：通过求解泊松方程实现图像的无缝混合。泊松混合可以有效地处理图像边界处的颜色过渡问题，实现自然的混合效果。原理是用泊松方程来平滑图像边界处的颜色差异，从而实现无缝拼接。泊松混合的数学表达式为：$\\nabla^2 I &#x3D; \\nabla \\cdot \\mathbf{v}$其中$I$为混合后的图像，$\\mathbf{v}$为图像梯度场。\n\n高层视觉1:SfM和SLAM(第10讲)相机标定指的是确定摄像机的内参和外参的过程。一般先进行内参标定，再进行外参标定。内外参矩阵的表示如下：\n\n内参矩阵$K$：$K &#x3D; \\begin{bmatrix} f_x &amp; 0 &amp; c_x \\ 0 &amp; f_y &amp; c_y \\ 0 &amp; 0 &amp; 1 \\end{bmatrix}$其中$f_x$和$f_y$为摄像机在x和y方向的焦距，$c_x$和$c_y$为主点坐标。\n外参矩阵$[R|t]$：$[R|t] &#x3D; \\begin{bmatrix} r_{11} &amp; r_{12} &amp; r_{13} &amp; t_x \\ r_{21} &amp; r_{22} &amp; r_{23} &amp; t_y \\ r_{31} &amp; r_{32} &amp; r_{33} &amp; t_z \\end{bmatrix}$其中$R$为旋转矩阵，描述摄像机坐标系相对于世界坐标系的旋转关系，$t$为平移向量，描述摄像机坐标系相对于世界坐标系的平移关系。\n\n摄像机的外参估计：\n外部参数物理意义:旋转矩阵$R$表示摄像机的朝向，描述了摄像机坐标系相对于世界坐标系的旋转关系。平移向量$t$表示摄像机的位置，描述了摄像机坐标系相对于世界坐标系的平移关系。\n外参估计方法：\n\n直接线性变换（DLT）：通过建立投影矩阵与三维点和二维点之间的关系，求解外参。公式为：$P &#x3D; K[R|t]$其中$P$为投影矩阵，$K$为内参矩阵，$R$为旋转矩阵，$t$为平移向量。通过最小化重投影误差，可以求解外参。直接线性变换（DLT）是一种用于估计摄像机外参的方法，通过建立投影矩阵与三维点和二维点之间的关系，求解外参。\n具体例题：假设已知三维点$X &#x3D; [X, Y, Z, 1]^T$和对应的二维点$x &#x3D; [u, v, 1]^T$，通过DLT方法可以构建线性方程组：\n\n\n$\\begin{bmatrix} u P_{3}^T - P_{1}^T \\ v P_{3}^T - P_{2}^T \\end{bmatrix} \\begin{bmatrix} R \\ t \\end{bmatrix} &#x3D; 0$通过最小二乘法求解上述方程组，得到摄像机的外参$R$和$t$。\n\n三角测量：通过多个摄像机视图中的对应点，利用几何关系计算三维点的位置。公式为：$X &#x3D; (P_1^T P_1)^{-1} P_1^T P_2 x$三角测量是通过两个或多个摄像机视图中的对应点，利用几何关系计算三维空间中点的位置。\n具体例题：假设有两个摄像机视图，摄像机1的投影矩阵为$P_1$，摄像机2的投影矩阵为$P_2$，对应的二维点分别为$x_1$和$x_2$。通过三角测量方法，可以构建线性方程组：\n\n\n$\\begin{bmatrix} x_1 P_{1,3}^T - P_{1,1}^T \\ y_1 P_{1,3}^T - P_{1,2}^T \\ x_2 P_{2,3}^T - P_{2,1}^T \\ y_2 P_{2,3}^T - P_{2,2}^T \\end{bmatrix} X &#x3D; 0$通过最小二乘法求解上述方程组，得到三维点$X$的位置。\n摄像机的内参估计：摄像机的内部参数描述了摄像机的光学特性和成像过程。内参包括焦距$f$、主点坐标$(c_x, c_y)$和畸变参数等。\n一般过程: 包括拍摄标定板图像，提取特征点，建立投影模型，求解内参。\n焦距估计公式为：$f &#x3D; \\frac{d \\cdot s}{D}$其中$d$为摄像机到标定板的距离，$s$为标定板上特征点的实际尺寸，$D$为图像中对应特征点的像素距离。\n畸变估计公式包括径向畸变和切向畸变，常用的径向畸变模型为：$x_{distorted} &#x3D; x(1 + k_1 r^2 + k_2 r^4 + k_3 r^6)$，$y_{distorted} &#x3D; y(1 + k_1 r^2 + k_2 r^4 + k_3 r^6)$其中$(x, y)$为未畸变的像素坐标，$(x_{distorted}, y_{distorted})$为畸变后的像素坐标，$r$为像素点到主点的距离，$k_1, k_2, k_3$为径向畸变系数。\n极线几何约束：极线几何描述了两个摄像机视图中对应点之间的关系。对于一个图像中的点，其对应点必须位于另一个图像中的极线上。极线方程为：$l’ &#x3D; F \\cdot p$其中$l’$为极线，$F$为基础矩阵，$p$为图像中的点。极线几何约束可以用于立体匹配和三维重建。\n光束平差法在SLAM中的应用：光束平差法在SLAM中用于同时优化摄像机的位姿和地图点的位置。通过最小化观测误差，实现对摄像机轨迹和环境地图的精确估计。光束平差法包括以下步骤：\n\n构建观测模型：建立摄像机位姿和地图点位置与观测点之间的关系。\n定义能量函数：能量函数包括观测误差和先验信息。\n最小化能量函数：通过非线性优化方法求解最小化问题，得到最优的摄像机位姿和地图点位置。\n\nSfM和SLAM的区别：SfM（Structure from Motion）和SLAM（Simultaneous Localization and Mapping）都是用于估计摄像机位姿和地图点位置的方法，但它们的应用场景和目标有所不同。\n\nSfM：主要用于从多个摄像机视图重建三维场景，不需要事先知道摄像机的位姿。它通过分析多个视图中的对应点，利用几何关系计算三维点的位置和摄像机的位姿。SfM的目标是重建三维场景，包括场景的结构和摄像机位姿。\nSLAM：主要用于实时估计摄像机的位姿和构建环境地图，通常应用于机器人导航和增强现实等领域。SLAM需要在未知环境中同时进行定位和地图构建，目标是实现实时的位姿估计和环境感知。\n\nSLAM系统的整体组成：\n\n传感器数据获取：获取摄像机的图像数据或激光雷达点云数据等。通常使用SIFT、ORB等特征点检测算法，提取图像中的特征点，并进行匹配，找到不同帧之间的对应关系。\n特征提取与匹配：从图像或点云中提取特征点，并进行特征匹配，找到不同帧之间的对应关系。\n位姿估计：利用特征匹配结果，估计摄像机的位姿变化。通过PnP算法、ICP算法等方法，估计摄像机的位姿变化。\n地图构建：根据位姿估计结果，构建环境地图，包括三维点云、纹理地图等。利用三角测量、体素网格等方法，构建环境地图。\n优化与闭环检测：对地图和位姿进行优化，并检测闭环，以实现地图的完整性和一致性。使用图优化、非线性最小二乘等方法，对地图和位姿进行优化，提高精度。通过识别已经访问过的场景，实现地图的闭环，减少累积误差。\n\n高层视觉2:深度估计(第11讲)对应关系的相似度度量，对应关系建立算法的主要模块：对应关系的相似度度量用于评估两个图像块之间的相似程度，常用的度量方法包括SSD（Sum of Squared Differences）、SAD（Sum of Absolute Differences）和归一化互相关（NCC）。对应关系建立算法的主要模块包括特征提取、特征匹配和优化处理。\n\nSSD：计算两个图像块像素值差的平方和，公式为：$SSD &#x3D; \\sum_{i,j} (I_1(i,j) - I_2(i,j))^2$\nSAD：计算两个图像块像素值差的绝对值和，公式为：$SAD &#x3D; \\sum_{i,j} |I_1(i,j) - I_2(i,j)|$\nNCC：计算两个图像块的归一化互相关，公式为：$NCC &#x3D; \\frac{\\sum_{i,j} (I_1(i,j) - \\bar{I_1})(I_2(i,j) - \\bar{I_2})}{\\sqrt{\\sum_{i,j} (I_1(i,j) - \\bar{I_1})^2 \\sum_{i,j} (I_2(i,j) - \\bar{I_2})^2}}$其中$I_1$和$I_2$为两个图像块，$\\bar{I_1}$和$\\bar{I_2}$为图像块的平均值。\n\n**对应关系全局优化方法有哪些?**：常见的对应关系全局优化方法包括图割优化、动态规划和信念传播等。\n\n图割优化：通过构建图模型，最小化能量函数实现对应关系的全局优化。\n动态规划：通过递归分解问题，利用子问题的最优解构建全局最优解。\n信念传播：通过在图模型中传递信息，实现对应关系的全局优化。\n\n**三维形状表示方法(深度图、网格、点云、图像块云、体积模型)**：\n\n深度图：每个像素存储对应点的深度值，适用于单目深度估计。\n网格：通过连接三维点形成多边形网格，适用于三维模型表示。\n点云：由大量三维点组成，适用于三维扫描和重建。\n图像块云：将图像块作为三维点的集合，适用于纹理映射。\n体积模型：通过体素表示三维空间，适用于医学成像和科学计算。\n\n**多视几何误差估计基本方法(公式)**：多视几何误差估计常用的方法包括重投影误差和三维点误差。\n\n重投影误差：衡量三维点投影到图像平面上的误差，公式为：$E_{reproj} &#x3D; \\sum_{i&#x3D;1}^{n} | p_i - \\hat{p}_i |^2$其中$p_i$为观测点，$\\hat{p}_i$为重投影点，$n$为点的数量。\n三维点误差：衡量三维点位置的误差，公式为：$E_{3D} &#x3D; \\sum_{i&#x3D;1}^{n} | P_i - \\hat{P}_i |^2$其中$P_i$为真实三维点，$\\hat{P}_i$为估计的三维点，$n$为点的数量。\n\n单目深度估计方法分类：单目深度估计方法根据所采用的模型和算法可以分为以下几类：基于几何的方法、基于学习的方法和基于优化的方法。\n\n基于几何的方法：通过几何关系计算深度，如立体视觉、光流和结构光等。\n基于学习的方法：利用深度学习模型进行深度估计，如深度神经网络和卷积神经网络等。\n基于优化的方法：通过优化目标函数进行深度估计，如光束平差法和最小二乘法等。\n\n高层视觉3:三维重建(第12讲)**可用于恢复三维模型的信息(明暗、纹理、焦点……)**：用于三维重建的信息包括：\n\n明暗信息：通过分析图像中的光照变化，恢复物体的表面形状。\n纹理信息：利用图像中的纹理特征，增强三维模型的细节表现。\n焦点信息：通过焦点变化，估计物体的深度信息。\n轮廓信息：通过提取物体的轮廓，辅助三维模型的构建。\n运动信息：通过分析物体的运动，恢复三维结构。\n\n**三维成像设备原理分类(结构光、时间飞行法……)**：\n\n结构光成像：通过投射已知结构的光图案，利用图案变形恢复三维形状。\n时间飞行法（ToF）：通过测量光信号从发射到接收的时间，计算物体的深度信息。\n立体视觉：通过两个或多个摄像机视图，利用视差计算三维结构。\n激光扫描：通过激光束扫描物体表面，获取高精度的三维点云数据。\n多视图重建：通过多个视角的图像，结合几何关系恢复三维模型。\n\n**三维结构表示方法及优缺点(基于点、线、面、体的表示)**：\n\n基于点的表示（点云）：优点云表示简单，易于获取，但缺乏表面信息，难以表达连续性。\n基于线的表示（线框模型）：优点能够表达物体的边界和结构，但难以表示复杂表面。\n基于面的表示（网格模型）：优点能够表达物体的表面形状，适用于渲染，但计算复杂度较高。\n基于体的表示（体素模型）：优点能够表达复杂的三维结构，适用于医学成像，但存储空间需求大。\n\n高层视觉4:图像识别(第13讲)图像识别的各项任务定义及相互关系：\n\n图像分类：将图像分配到预定义的类别中。\n目标检测：在图像中定位并识别特定目标。\n语义分割：为图像中的每个像素分配类别标签。\n实例分割：不仅分配类别标签，还区分同类别的不同实例。\n关系：图像分类是基础任务，目标检测和语义分割在分类基础上进行扩展，实例分割结合了目标检测和语义分割的特点。\n\n每种任务的经典模型：\n\n图像分类：经典模型包括AlexNet、VGG、ResNet等。\n目标检测：经典模型包括R-CNN、Fast R-CNN、Faster R-CNN、YOLO、SSD等。\n语义分割：经典模型包括FCN、U-Net、DeepLab等。\n实例分割：经典模型包括Mask R-CNN等。\n\n计算机视觉+X(第14讲)计算摄影学的概念: 是新兴的交叉研究领域，旨在通过可计算的图像获取、处理和操纵技术，将软硬件有机结合起来，克服传统数码相机的局限性，实现对图像能力的增强或扩展。主要研究方向包括：\n\n光度校正（Photometric Calibration）：目标是校准测量或记录光强度的设备，确保获取数据准确反映实际光度量，通过1、相机响应函数（CRF）标定：将相机接收到的场景辐射度转换为图像像素亮度值；2、晕影效应校正：图像外围亮度比中心区域低的现象校正。\n高动态范围成像（HDR）：亮的地方更亮，暗的地方更暗，亮度跨度很大，实现比普通数字图像技术更大曝光的动态范围，可以在一张照片中呈现更大的明暗差别（避免曝光不足或过度曝光）\n图像超分辨率：提升图像分辨率，从低分辨率图像生成高分辨率图像，通过算法恢复丢失的细节信息\n图像抠图：从背景中分离前景对象，实现精确的前景提取\n图像合成：将多个图像组合成一个新图像，包括纹理分析与合成\n\nCV+CG的主要任务: CV+CG的主要任务包括：\n\n视图插值：从已知视角生成新视角的图像，用于虚拟现实和增强现实应用\n分层深度图像：为图像中的不同对象分配深度信息，用于3D重建和场景理解\n光场和发光图：光场技术记录光线的方向和强度，发光图用于高效渲染光照效果\n环境遮罩：从图像中提取物体与背景的边界信息，用于图像合成和场景编辑\n视频渲染：将计算机生成的3D模型实时渲染为视频，用于游戏、电影特效和虚拟现实\n\nCV+NLP为什么要结合：视觉和语言是人类获取信息的两大主要渠道，结合CV和NLP可以实现更全面的信息理解。计算机视觉（CV）和自然语言处理（NLP）的结合有助于实现更智能的系统，如图像描述生成、视觉问答等。通过结合视觉和语言信息，系统能够更好地理解和解释图像内容。\nAGI的理解:AGI（Artificial General Intelligence）指的是具备广泛认知能力的人工智能系统，能够像人类一样理解和处理各种任务，而不仅仅是执行特定任务。是一种通用人工智能，能解决一般问题，具备推理和主动学习能力。ANI（Artificial Narrow Intelligence）：专用人工智能，解决特定问题（如人脸识别、图像分类）；ASI（Artificial Super Intelligence）：超级人工智能，超越人类智能。我们目前仍处于ANI阶段，需要从专用智能向通用智能发展，CV+X（X&#x3D;CG、NLP等）是实现AGI的必经之路。\n计算题\n相机内参矩阵的计算：假设已知摄像机的焦距$f$，主点坐标$(c_x, c_y)$，则摄像机的内参矩阵$K$可以表示为：$K &#x3D; \\begin{bmatrix} f &amp; 0 &amp; c_x \\ 0 &amp; f &amp; c_y \\ 0 &amp; 0 &amp; 1 \\end{bmatrix}$\n\n相机外参矩阵的计算：假设已知摄像机的旋转矩阵$R$和平移向量$t$，则摄像机的外参矩阵$[R|t]$可以表示为：$[R|t] &#x3D; \\begin{bmatrix} R &amp; t \\ 0 &amp; 1 \\end{bmatrix}$\n\n视差与深度的关系：假设有一个立体摄像机系统，基线长度为$B$，焦距为$f$，视差为$d$，则深度$Z$可以通过以下公式计算：$Z &#x3D; \\frac{fB}{d}$其中，$f$为焦距，$B$为基线长度，$d$为视差。\n\n投影变换的计算：假设有一个三维点$P &#x3D; (X, Y, Z)$，摄像机的内参矩阵为$K$，外参矩阵为$[R|t]$，则该点在图像平面上的投影点$p &#x3D; (u, v)$可以通过以下公式计算：$p &#x3D; K [R|t] P$具体计算步骤包括：\n\n\n\n将三维点$P$转换为齐次坐标形式：$P_{h} &#x3D; (X, Y, Z, 1)$\n计算摄像机坐标系下的点：$P_{c} &#x3D; [R|t] P_{h}$\n计算图像平面上的投影点：$p_{h} &#x3D; K P_{c}$\n将齐次坐标转换为非齐次坐标：$u &#x3D; \\frac{p_{h,x}}{p_{h,z}}, v &#x3D; \\frac{p_{h,y}}{p_{h,z}}$\n\n\n计算图像的灰度值：假设有一个RGB图像的像素值为$(R, G, B)$，可以通过以下公式计算其灰度值$Y$：$Y &#x3D; 0.299R + 0.587G + 0.114B$其中$R, G, B$分别为红、绿、蓝通道的像素值。 \n\n计算图像的直方图均衡化：假设有一个灰度图像，其像素值范围为0-255，可以通过以下步骤进行直方图均衡化(OpenCV实用公式)：\n\n\n\n计算图像的直方图$h(i)$，其中$i$为像素值。\n计算累积分布函数（CDF）：$c(i) &#x3D; \\sum_{j&#x3D;0}^{i} h(j)$\n归一化CDF：$c_{norm}(i) &#x3D; \\frac{c(i) - c_{min}}{N - c_{min}} \\times 255$其中$c_{min}$为非零CDF的最小值，$N$为图像的总像素数。\n使用归一化的CDF映射原始像素值，得到均衡化后的图像。\n\n\n计算图像的傅里叶变换：假设有一个二维图像$f(x, y)$，其傅里叶变换$F(u, v)$可以通过以下公式计算：$F(u, v) &#x3D; \\sum_{x&#x3D;0}^{M-1} \\sum_{y&#x3D;0}^{N-1} f(x, y) e^{-j2\\pi(\\frac{ux}{M} + \\frac{vy}{N})}$其中$M$和$N$分别为图像的宽度和高度，$j$为虚数单位。 \n\n滤波计算：将卷积核的每个元素与图像的对应元素相乘，然后求和，得到滤波后的像素值。在边界处，可以使用零填充或镜像填充等方法处理。关于卷积核是否归一化的问题，通常情况下，卷积核需要进行归一化处理，以确保滤波后的图像亮度不会发生显著变化。归一化的方法是将卷积核的所有元素之和归一化为1，即：$K_{norm}(i,j) &#x3D; \\frac{K(i,j)}{\\sum_{m,n} K(m,n)}$其中$K(i,j)$为卷积核的元素，$K_{norm}(i,j)$为归一化后的卷积核元素。10. \n\nHarris角点响应计算：假设有一个图像$I(x, y)$，可以通过以下步骤计算Harris角点响应R值：\n\n\n\n计算图像的梯度：$I_x &#x3D; \\frac{\\partial I}{\\partial x}, I_y &#x3D; \\frac{\\partial I}{\\partial y}$\n计算矩阵M的元素：$M &#x3D; \\begin{bmatrix} I_x^2 &amp; I_x I_y \\ I_x I_y &amp; I_y^2 \\end{bmatrix}$\n计算矩阵M的特征值$\\lambda_1$和$\\lambda_2$。（计算特征值的方法：对于2x2矩阵$M &#x3D; \\begin{bmatrix} a &amp; b \\ b &amp; c \\end{bmatrix}$，其特征值可以通过求解特征方程$|M - \\lambda I| &#x3D; 0$得到，即：$\\lambda^2 - (a + c)\\lambda + (ac - b^2) &#x3D; 0$，解出$\\lambda_1$和$\\lambda_2$）\n计算Harris角点响应R值：$R &#x3D; \\lambda_1 \\lambda_2 - k(\\lambda_1 + \\lambda_2)^2$其中$k$为经验常数，通常取值为0.04-0.06。最终R值越大，表示该点越可能是角点。\n\n\n对极几何计算：假设有两个相机$C_1$和$C_2$，它们的内参矩阵分别为$K_1$和$K_2$，外参矩阵分别为$[R_1|t_1]$和$[R_2|t_2]$，可以通过以下步骤计算基础矩阵$F$：\n\n\n计算相机的投影矩阵：$P_1 &#x3D; K_1[R_1|t_1]$，$P_2 &#x3D; K_2[R_2|t_2]$。\n计算基础矩阵：$F &#x3D; K_2^{-T}E K_1^{-1}$，其中$E$为本质矩阵，可以通过$E &#x3D; [t]_x R$计算得到。\n极线方程：对于图像上的一个点$p_1$，其在另一幅图像上的极线方程为$l_2 &#x3D; F p_1$。\n\n补充内参 vs 外参：内参描述相机内部属性，外参描述相机姿态基础矩阵 vs 本质矩阵：他们都描述两个视图间的几何关系，基础矩阵适用于未校正图像，本质矩阵适用于校正图像SIFT vs SURF vs ORB：SIFT最稳定但慢，SURF较快，ORB最快，他们都是特征点检测和描述算法SSD vs NCC：SSD对亮度敏感，NCC对亮度变化鲁棒，NCC计算复杂度高，适用于光照变化大的场景，他们都是图像配准算法，用于将一张图像中的特征点与另一张图像中的对应点匹配。图像分类 vs 目标检测 vs 实例分割：分类：整图类别；检测：定位+分类（边界框）；实例分割：像素级分类+实例区分SfM vs SLAM：SfM（Structure from Motion）：离线，多视图，高精度重建；SLAM（Simultaneous Localization and Mapping）：在线，实时，定位与建图传统方法 vs 深度学习方法：传统：特征工程+机器学习 深度学习：端到端学习，特征自动提取经典CNN架构：AlexNet：首个成功CNN，ReLU，Dropout，数据增强；VGG：小卷积核（3×3），深层网络；ResNet：残差连接，解决梯度消失；U-Net：编码器-解码器，跳跃连接，用于分割；YOLO：单阶段检测，将检测视为回归问题;损失函数：分类：交叉熵损失；检测：Smooth L1损失（边框回归），Focal Loss（处理类别不平衡）；分割：Dice Loss，BCE损失；评价指标：分类：准确率，精确率，召回率，F1分数；检测：mAP（平均精度均值），IoU；分割：mIoU（平均交并比），像素精度。\n","categories":["Course"],"tags":["CV"]},{"title":"接受现实并苏醒","url":"/2025/08/06/Diary/2025-08-06%20%E6%8E%A5%E5%8F%97%E7%8E%B0%E5%AE%9E%E5%B9%B6%E8%8B%8F%E9%86%92/","content":"\n      \n        11ea40d3acaa89334d4cf31b071a4be1b55d177d27c4f5bc0712e9c1175cdb807bdcdb45dbc76c0cca7f31ad13980bba5f874450e10e6e13aea151c139aa4ccc8a873d9281b6d634d3e6e08e9baa53a879dadf61db2de8af8f5048f8e8a60c751e6ab8ae3497dc61da519dbc8e5c6c9593aa4b53e17d6a57d35153e2c0527dbddbf54262ab007c9c410b2015aa4acb6f8361e521069dd9923480e44e39f7cce1d31621cb0df83bb4e2e90f853759ab7be4a1d2f55de253f76349821e7067c5495bc14162f69a584c97becb2707a707c11b1c4d979c3682c7ebc1808b37641e0d83ce0148998e36bcd8666954d9dd494d7286af1fe04534c55fde564696e97223fd0529959103032868779bf3094e0cb5c24e0d0fdd6abf2a6bf0c7e82683dc1bf79477eb76472b39ef8a680c25ec18939cbafa38133d67ebcff6cc3ed3ff1b7fe0e932b874dbbff0fee57448eb607c3feb822b923d6cd8499f940320bc1d963608194d7cf88eed33a17954d643ef9f8975782b90d3335e0bdd882e6e844b2cf726198bdab0d950fcc2f95200b8319c42259b1cd42ffd51ee5af882e93cd9a0301f1cc1d66897e3410a72860616f314cd7c60e66854d96204d2962ce7aa45ffc9e826ceeb1d5bd23dc2a98983f63fb902da50acde5b48d5a85093ac43373e5799d33c62dc1745c0e6600d32c0e2ef9afda84a07af8bc6068625a9fea9aba33405c74b56d3224fece4707c75e7f168a9a971bb6aeda65ba90cb949dd9dbf22f25d0f8d9eff023d4e2f5f2f3b6759b0cf236900f12ecae7242157f53e8bd55eb4683f12c0f8d32e040546d2e9610085d1b3957382e52bd267e74d0e2192f5c48731cf5d73fb5b120e24673878078dfe31f502ada9ba2e768b9771fe69a782ae06273e1511e67bd34f34220d070af0534e44a1cbe60cd6874185285608dd1296cbb4336dc44ab532391b962c58abd370a76919a8b7b0440b35dc2cfd24fcecc66a2fae5de3693d71effb0afdc27e68b723f9\n      \n      \n        \n          \n          \n            请输入与 Nervld Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    ","categories":["Diary"],"tags":["Diary","🚩","☀️"]},{"title":"盲目了很多天的渲染，在某天夜晚","url":"/2025/08/10/Diary/2025-08-10%20%E7%9B%B2%E7%9B%AE%E4%BA%86%E5%BE%88%E5%A4%9A%E5%A4%A9%E7%9A%84%E6%B8%B2%E6%9F%93%EF%BC%8C%E5%9C%A8%E6%9F%90%E5%A4%A9%E5%A4%9C%E6%99%9A/","content":"\n      \n        11ea40d3acaa89334d4cf31b071a4be181a1d3c14f0ca0b49cbf82703cbbb221c9a1e31cd20bda316f857d0bdcad98e31237a12680befd6189e5e37724cb3fe0243314bfb7aa7c7800cf5235f4575f72544efd633a8176b587ab736b7c07eeefd0ad6bf619f4b2a476452e32b38942047052854fe302d7399b2ac4accc956838a473e93c726a1f4538334b635dd9d22f580bfa3769ff3f7254eb5ad1760ff95b60f733158a39154efa9e4a8bf8bea030d20a13bc15143c2ef337868e86472c462e352eaa35d008a098dc63e1424378854f911dfcfa4cfe10af8ca336df3f29f28c718fd6581a231b77e73112bbd6a69c5dc5406c45575d76390d2d3002e4c231f0c88b591d482e300aea707524df5e98bddd9db292bb45653f96bc6d88f67b0d3c382302731968f2e9c3c33d1e53ae081900b246c13dd8a8c4eae1dd534b111fba033823e8db3ce520954919b2c1315f8811217caade0f599c19c7a8f7f759b2d0686e037c909593d8c1a444e8ff438b535d1ed0093834d68aa3ab14c2ffd43d041d2795990da812437643e4827e40026cf5ded56419054572bd1d3e87893422639ea57b2db82764b1e70d38cc965bf3b61b89c2bf4dadb8d3e8869baf92380a30b909e51831e995626d5bd394838656c740dba7466b058d7f2adf71256abf360ae373a8ac04af9a20b56bb1e66f77a425cd0b7850b49240c7da82a5242a5e0a5161ea5994a428109473f0f2d8ff85b9a9367f3bd8e24918463c3e0dc8b40dc187446e9f05887e854b553e193fa5f0287a8119b2741868a51c1645d23f4f0b6c0f0ac18e38f1378830f2759470a8dc0ffb5d1578fae9378734ff73306132db6dc62552158d59169008684fd1fa431a877ca40b6695251d05c3870d761de11ced2e607ec65b10dedc302614510c92cfa9210266e3a7d4e99a7ab22e3524da557b6d42c69c02b65ecea49c59d9c16b0305a81c815b309267a4023649c1cc595983c31f9440d3201ddf16cf4607feabc96063421dc6cf7186dfdd9c5196dc562036234c9e4ba4903649df824cf27ea4826c0b3309ba9e8aaf645e4b476adfda5822db134b28133f58f0f4a099992efbc33c31799e0e9617d8f64880b9b507e2982336f06630d411243bf1c4426ad1494678563d219c2e3e0eb6c2356d83f8d3b8eb76446af5c965bb9ea4f9138d22698d704220ea6988c25bdc336d25f4ffb588bc8c70dcf9d846fb3420f9a92da532fe2daf5358149737905afc90135efd4e0620efe174de4fd184ec3cab21de4583074e70cb49c75a4434ea63a94316b25d92b39ed2be8dd0ff8cb042dfc6f35aab6da8dee0a81d32345d4e98ab5e4c97f35b0e43810b212b85526a65650660fcdd73727c51d05667af8a684d9c042a6b6ca485a35d0fd915078078d32cce221d99d9080146896d2770e5f5a41abdcb4675e742d686e98e5bb2115d947d1fa05f3a51a12e412ba52eae1008c073c176637da749d29bc2fd0a79081a18fe68af0ecb2cfd02909166639d316adb93e8c8f7904f3c23cddc1a34e5a8f3d78186d0f22acf4dc1e88614a2fa69626ebbd12b3ed78cc5b99094069f4f1b77e43bbc4b6339a4402b298899810e0f947cbc3e015489e76005caa01a6d25db7bec683fa90a4e3dd293ecdb79eaa5720ce68a747dd9cf732daaf5fd6cbae8241fbb2c49c0518539abe5793aa1f778b4c3d02055b654eff86045bc2f25bb900f9c02943edea0b6564ff72cc1fd3dc46a0c210d69058c217761b9a8496f6799f2996a25506f8f928b2b2f00cb531b1bbc637c8634795f2855b39e2add854cf7847d55c387086acb42386d0b6b68d54a017199296f2543c6c5c839771d380016f023bb3fb516e3dc0fa3a69acc9a54536ebb4174d93e50be932ee9699e5e72a2a447c1a2047b5cc82c50456658a51f01062984453ef3cf18cd0d775b38daa81c8346b5d8726081901cddc66cd685443c5f419f9626365209926058b6f0fced4d12281d00e6ab40aebc65e821a111740eefab7e0c244be59ade9e2c9bb9842a0c5c8df79d4673693198016381c9d267c6c05bde85924dcef1450879bacd39ab56175bce8cf5e497db49efcef67b8b81888223d181f74a18b44ae434427aa8d684ca749d25d5dd3a1ad41998a778ecf3d9a2aefcd7ef4aef4a734bf2f21e6ab4624602eefb1dd0830ec1662b8ef27db8f327d6aaa35ff05cf964c00a7d702dcea603f326a4d9ff157e9f0895eb1889f4cd3eff9615d6816bfd84e6\n      \n      \n        \n          \n          \n            请输入与 Nervld Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    ","categories":["Diary"],"tags":["Diary","🌧️","☀️","😐"]},{"title":"开学典礼与清华","url":"/2025/08/29/Diary/2025-08-29%20%E5%BC%80%E5%AD%A6%E5%85%B8%E7%A4%BC%E4%B8%8E%E6%B8%85%E5%8D%8E/","content":"今天也是较为充实的一天，了解了很多信息，也跟AI对话学习了很久，不过还是没有进入到实践与理论双修的程度，故由此思索后续规划。\n\n今天参加了清华大学研究生开学典礼，最后校长还给大家上了最后一堂课。校长说现在这个时代是AI的时代，所以会将AI作为所有专业的通识课程，并且还给大家提供了平台。清华的资源不必多说。\n晚上我去寝室楼健身房体验了一波，真的非常nice，以后也会多去体验。就在写这篇日记的时候出现了插曲，我还放弃了班长竞选，然后报名了校研会的信息方向，是做学校用的小程序的。\n总而言之，今天准备晚上再看点JVM书就结束了，明天下午要去参观学校艺术博物馆。\n希望之后有时间的时候可以心无旁骛的开始做自己的事情。多学一些有用的技术，由浅入深，有个清晰的脉络。\n就像我从走进这座紫色殿堂开始，留下一路芬芳的足迹和静谧温柔的印记。不要妄自菲薄，也不要和人比较，跟昨天的自己说“我今天更好了”，跟明天的自己说“你好，我来了”。另外反复强调，目标是找实习，而且是有技术追求的找实习。\n","categories":["Diary"],"tags":["OpenDiary"]},{"title":"烈阳之下的困倦","url":"/2025/08/05/Diary/2025-08-05%20%E7%83%88%E9%98%B3%E4%B9%8B%E4%B8%8B%E7%9A%84%E5%9B%B0%E5%80%A6/","content":"\n      \n        11ea40d3acaa89334d4cf31b071a4be17f9d2ae6278a63cd4d8842fdbf654c9353bc5b3cd063fdee55796366ba3e70b699bab5d8bc70d48a2932252761df5860d6503715633b9e10cbb17d90742da5c14b4608f8344593c694a25083e319ae96e169a13a5709603580a90432fac7a6aebad172981581c78e323eae7c0f484c05474c3d286ffd4a15f7042b297f3bd616019125787127e485ba3cf9ef846a4ce66e51080a1de99e6cd944a34a5709cb43a85a4c8bfe10dcfea7c5747c7e7c3547ca5921b327f71a346b7e0c251b4a59d46f3af7091f037d55d2b2c9357a0e633f7851de0b4d9f4c558a19aa42a0ec4cbadbfe30757ed0de9b6806c977d08cf1e407f4fba7d2a41a5d91829f3e45472fa9af8a981fb5ad60cdca5ace2c762fbd7c7756133d3a2187fbe26029867b08e046579c8513d3ea59790faed1381102536ee8a87485590129764d013b15371ac629f17c12d0a7e0372436479134f672c5fdea41d5132d2360be38de84e6668ab638d0d8b470b65596acf5144424d8e82be246df1624d6310e937b321f718a515fc3d9e27f484c0624380d4af8c3ee9c0a7610093dbead1923c04ae560b2d20af145c0f97f40caede21aad60bcf15419c82cd668ccd1674830d0de40bdee86043851d0d559d4bedf022db972cadb729ae1b7935ce5fe91ba54ab9ed36b14848d364f7cb5451f4f808347775be79c905a29e3a4fa1351dacf5f9134767c3cb54cc2ef01d25b09ad39fd5fbd9683dbb5c129cac64f00bc482fc79039b83c6a976e2a3cd32d9606934fef346a5eba63c4e604bab8dfbb92eade25750a7561528016b62573569bc297504ff700b60e5e71d4277ad44eefa2feef7a8b45e27a8c4d579b844ab2411ef5a83652a27aecbee721acacb975a3b22758992c6d8d630faf379c4a9ba9624e6be826ba396a8add8a3c1d503ca2196f27e40e80aa24c5e55f87e57a5d200553d128d89f583ac9f7de50c0a6d17f69f0d100f88a2ec31b6cf7dd0199b85bd3fda131b27881941ac01dd8290d4fd1c5ba9ef2020b5aebc81006bf2865cd92acf88e3ba166e7f7fcccac5e0c36048b8405608e09bdff63e95eba0fe8f23e41f9fc1ffd1fda4d946b0fbcc7e4b55c62437069b39c8eab8de87a8a733b1299965694808c864338dd84b352b891a036b51504dca4262247fce35cc3fd4f33521f0c03c57c6ca853d1e3f38c203f70a25ee026a269d8c8b33c5cf0d962fc326de5c96143670fd21a9f510a95674de3531800a72f7ada4d3abf8693aca64a668281574dffd3d7348a80f04215bc930432e064c26dfc63b128d2cc06d7a315b4d4ca535dad0bd763b1308eed268301b4169f813290e606f7db8973543b88e674e7dda4c0faa1708b42d95752994d57ce123c98b39c3cb0db9e0063aaee31c61eb8d7a39733d26cb89a75454dc6e3c312\n      \n      \n        \n          \n          \n            请输入与 Nervld Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    ","categories":["Diary"],"tags":["Diary","☀️","🙁"]},{"title":"时间是个作曲家","url":"/2025/08/19/Create/%E6%97%B6%E9%97%B4%E6%98%AF%E4%B8%AA%E4%BD%9C%E6%9B%B2%E5%AE%B6/","content":"屋檐上的雨滴，在几秒之后落进土里沉闷的空气在露珠形成以后重归透明我们的心在时间旅行之后难以平静仿佛时间把这段回忆做成歌曲\n时间是个作曲家你看他滴滴答答打着节拍望着人群行色匆匆的身影因为什么要别离\n世界像个时钟不停转连同着我们内心的期盼可来来回回的几个音阶缠绕在心头萦绕在梦中时间你说我该去哪里你打的节拍我有点听不清\n时间是个作曲家我们也川流不息望着风景感受生命行色匆匆的身影因为什么而相聚\n在这里的简单日常点缀了我回忆里的满天星光梦醒时分的微风吹拂饭后散步的月色微微走过的小路不算丰富确实人生阶段最喜欢的间奏时间是个作曲家把每段时光都刻画的让人难忘每当旋律再次响起又是何时热泪盈眶\n时间是个作曲家每段乐章都有结束的地方人生的色彩反复无常做成一首歌显得冗长拆成乐章又显得无章每段乐章的结束余韵还未消散新的乐章开始带着时间与风的气压我们不得不接受变化\n","categories":["Create"],"tags":["歌词"]},{"title":"一个人在宿舍的思考","url":"/2025/09/25/Diary/2025-09-25%20%E4%B8%80%E4%B8%AA%E4%BA%BA%E5%9C%A8%E5%AE%BF%E8%88%8D%E7%9A%84%E6%80%9D%E8%80%83/","content":"转眼过去快一个月了，是时候总结一下了～\n\n最近的状态似乎不如新生教育的时候那般热切的渴求将自己的所有时间填满，慢慢的，很多其他事情涌入日程，使得生活支离破碎起来。\n就好比食堂，在最开始的时候，每天带来的新鲜感，随着简简单单的两周过去，逐渐变得不那么令人兴奋，偶尔看到学校的风景，还是会想起初来乍到时的隐隐决心。\n现在学生工作是多的，工作效率是还算可以的，自己的成长路线是模糊的，每天的精力是比较充沛的。\n所以是时候做出一些改变了，我知道国庆之后一切又会变得不太一样，我们得进入课题组进行长线课题的研究，那我认为这段时间还是主要聚焦在八股的输入上吧～然后leetcode也会慢慢熟练起来（今天刚配置了vscode的leetcode刷题环境）\n现在的我一个人在寝室，室友A应该在实验室，室友B也许在外面学习吃饭。这些对我来说是简单的日常，我觉得此时此刻还算不错。\n今天早上一上午的课，我一直在摸我新买的mac的启动台，课也没怎么听，其实觉得有些课真的比较枯燥，而且对未来找工作说不上什么帮助。\n周围的人确实有时候会不知不觉的焦虑，受到外界的影响。我的话还是有比较清晰的路线的，但是有时候明明可以去做一件事的时候，想到事情的复杂度，自己却又打起退堂鼓来。后面我还是觉得要敢闯敢冲，同时也不要丢了开学时那份好奇心和对知识的渴望吧，即使再复杂，也总会有路口可以通过。\n今天就写到这里吧，马上我决定去吃个饭～想想碎片🧩时间的利用～\n~吃完饭了，在安慰女朋友的时候，我也想到，代码是不会说谎的朋友，你和他交流永远是有意义的，所以不要将多余的心力放到它以外的地方，这样也许对自己不善处理同辈压力的🧠一点点释怀～\n","categories":["Diary"],"tags":["OpenDiary"]},{"title":"平凡的周六","url":"/2025/09/27/Diary/2025-09-27%20%E5%B9%B3%E5%87%A1%E7%9A%84%E5%91%A8%E5%85%AD/","content":"\n      \n        b290246a572563c4509f4f34c9013848ff7f346a7d373c8d8d4e197168226c5e64db1fb87b086003d1c723704aec0d1f89304720faabed28a8c67bacee2c302eb4a8bb5cb8583ea282f5595027f1c1fcb3dc4be4768d945723a4191b1fea1823c32ddcc20cfc866f3745048b5490a3151c1617935ea6289b9fb09ac9e7898fd3429630946befab979b3e9a7d888b023022c4377915de45876b3593695e5a8e9ba873cf338110f6c1498c8fff5aa605cc8bc730a332db6b64e64a0befbfbf2c6d65759b00cd86bee3653f1cb40b1c1c5f0deef1a0404a9bd6ccc18657478bfd468375d5d29fe35fee641f8a33bd8d75123c9121bfad8931cbecfd878f6c37973479862d97e93509d2d3b9edb3e20cf903a45f773bc50d05c73c0499454192acdb06eff8c7213f6883e468c9d63b6b0e837753ca3e93767c1e685379f61421b6a2d533a0fd6f9bb25d7ac281831ea011231ac06b7afab573b64d287de47d48fc815a0923c36146993c169488fa2f3c07438558367af123ae4ff033ffe4cb465c84143238dc3d35d2be47e8310a55984b8cf69d9d1b20f5714d7ef71e99f1e05f0c5566d1cc0b3ee33c8112e6dfd9cc4a9e966de0b0f2a91ac6d5a931529a884b3c140d664504ae4380282e46beec1511d3f12cb47946787a2a316e29b75eedde9b1c6702169692d62ce4bb6a398b131aa06b6fb2f3876134418c864ea77366d81b97f91785c989c0889a053a10ddeae8aa0da52e47a195acb0e7f03291f39d706b4835e070bac0fa62726854f1f4f72d1033020293a4a7a1ffc5f7032389905ef7705580e28f73194d5345fd04127f2540d6cc3f416f7be8a7902bbef1f49eaf66831c15469733b575c89cb28c1b78060e69ed543f0a1751ca93bf203f2f5c03eea2b53da15a8a12ee86f2104f6f01b3d5f344164803fa0ae0601fba69dfb2e04a66cc0f4e0c4876bde1003b2f275d29fc4681e06cea1c4f99f18c2d4ec3fc0304028d4185fc24bd14b81a1fd3b3a865c407d9b58668037e11dbd463ea83c56c0f6b3dfcc7bd3a8c45aff2480ab37a9287b1dfd7a4c5c66fa6335d551f37036fcb7ea347a4311a6fa6248f9d7e3e4103e3\n      \n      \n        \n          \n          \n            请输入与 Nervld Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    ","categories":["Diary"],"tags":["Diary","🙁"]},{"title":"计算机动画课","url":"/2025/09/28/Course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A8%E7%94%BB%E8%AF%BE/","content":"j# 粒子系统Mesh不太好表示的部分假设：\n\n粒子有生命周期\n一般不碰撞\n\n欧拉积分方法Verlet积分方法（蛙跳版用的更多）\n群组系统几何飞行\n\n考虑重力，但是只用来计算倾斜（Banking）\n一只鸟不会把注意力放在鸟群的所有鸟上\n只观察自身一个小范围内的鸟群\n\n\n两个平衡但是相反的行为：\n与其他鸟群靠近（群体合群原则）\n与其他鸟不碰撞（碰撞避免原则）\n尽量与周围群体鸟速度一致（速度匹配原则）\n努力摆脱迫在眉睫的影响（碰撞避免）\n\n\n三个行为表现为：\n广义的加速请求\n根据优先级加权平均\n仲裁方式\n\n\n感知模拟（只考虑前面大半圆的邻居）\nFlocking的整体控制\n整体目标\n整体位置\n有界加速\n矢量动画\n路径\n\n\n\n三种层次行为\n\n实体化个体行为 locomotion\n抽象化导航行为 Steering\n\n徘徊行为要保持一个徘徊方向，进行飘忽移动\n","categories":["Course"],"tags":["计算机图形学"]},{"title":"在爱情里面无所适从","url":"/2025/09/30/Diary/2025-09-30%20%E5%9C%A8%E7%88%B1%E6%83%85%E9%87%8C%E9%9D%A2%E6%97%A0%E6%89%80%E9%80%82%E4%BB%8E/","content":"\n      \n        3005c8c61f4f4bc6df7b8c7a8bbeda6d16673c897477566725e746249f3fe1e7eef4acd0f6e432407084d66f9d925ec9da5367b5c6c94ec4adabcba0287715039561181260474e851569d5ebc5da486f738e1203d3595b335a445b85ab23048bb5e756d4e46cdc27d8c5497ec6bebe39c81c1aab0b84e00ffd08d24ca15a3855d9c717338b86e575b0932f9efab9c34351dd57b738285510ca18962119a74494034400d2024854872facfca6b6f56dac2893a870110fa354b6bb0536f3f4091a133adc4270f387d2a3c7dd3744e91beb4217132ebf52f2e91619a10c843ed789ba0bca26c75dece9132d31face4267ff5791cb71f854b8b70db1c5beae9e3b508d13aeb506cfbf0f5d9926da977d95e9784ea43fa0ee058f1bd086c193f13ea35800b7089879cf96c9697ba902eff464c839314ccd7280104cbea40de2810f77ed6b223c3e1f23a3e5bb386f765bf494d3f213578c2a884d3b6cc0715da086865c60d99db6b6cba6aeb3d73d31598992de8d24f9bced24b703cdfffdc2c703051a26ef28ba999b86f82e1cf3df34cc76ccfce63c4232f47943cfab5c62a957591fbf6b15ef41acdc7fc3911d53a139abdbf96c875eb01602bc510a5aec31e4fa164709619e7b0a317b9408d125e3cde1ce8e3ece117b0cb4f271a0a4553d39c4872357256d8156c2dad4bb13ed151d79483fe9cfc0e1448d30d889e80d2b1f92909f8f0e555ff53645b2d4f1c95019b27d8769593a0998f8009f9b174e27cdc5d8603d514f1135149d121630f87da7ebc786321e7867d9ae016b259c68ef72a6cc77ee55cacd05e157cd8de2308cb9275fd377597dfabd87c13d81b10cffdb164b8b2ad180d533ad31c934931277f0ebb02505dfb0db35992eb77fb888e7241529c880eb04e2031b4366f759fe7f3492224c3775f447f7e072430f78486eb367c316364594a71b9fc9da9d7007b7a192ebd7fedd7b5bfe67827036132a94248e171ed177d504c8092d3ff4b6db2ff03ae303151874cdb2a5a097d069b6983946f842b8cff4d1186722a7023022296c0540281ce5ac565d04c962cc5b3c4ed010ec5e484e39174161f5adb078b002d0c6e6467df4576143984f0741166952be23483667f0d9565e43b2c046bc7290229bc3643b5758d8293e2b2fb606a34d08967f00b392ff340386cd2072e63a2de299ac0a815b1cad13634b2d15b3ebf4153d2d75b34a51ba07a0fffccc51289d907895e7e0dfa2b37353ddaa2a249875bb9b953dfb81966efaf60cf686cf22cab79e9fb2c74dc56bc5454ab01a4bf389c043ad13267a0ccb6ccc79b08535ff628f0632f7668bb4aeda2e50bd3df6043207590714c8542c467a968cf33f811fc5acd82d78dcb06ea4f1d8e94b428db36eb691955de5b042106ecb05ce89a48bcfb9a4aa3064032860dac39ac8a6008f73fce0139083e454b5f1e869dad4f283eb28d5\n      \n      \n        \n          \n          \n            请输入与 Nervld Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    ","categories":["Diary"],"tags":["Diary"]},{"title":"一个人的国庆","url":"/2025/10/01/Diary/2025-10-01%20%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%9B%BD%E5%BA%86/","content":"\n      \n        3005c8c61f4f4bc6df7b8c7a8bbeda6d23916a6834ab607588eb818cf169f1139d19a8cd63f24717aa6284f406b9bfdacfdd2cdb41dde10c7d4518548baa5d1d814e2af2bb049f4db5a721538f4089687cbe7457455d987b887911c41d1d688d4ec429530d17055538a04e6b1c17600c74b3dbc1f01c763ee8fe9a480422f03d406ef4651e4a659ac4381bce4a1674a61e0b69134b986afdc3c55fb6df474dccbd144bdb1c8fe759d4258443cafa9ff11b613ad72fe4a7bfa6c9c575b9f86c8d919dfdd99bd491e154e0ab299b4a751029c25554ce647a02a78dcb35062b7d8ce031a447ab30478549583cd29c19486ede40ca248adf09141050e0e00c8f7d69b0f3393201e1a69d33d12dbd5921fe4b97babd9262a1ba415adb32e2d8454a253f0d8ab093818bea090d1b40b728dab8fc7defd47a7e60ee8f0e922df31b304d06e0e6bcc00bfeda5f5f8504caa9e390c56b59f27cd4cdf94d313f694fec0ecd2f52a72b4d013559d9b058fde7aa604a632a3d13461fec39986bb64c9bd2b929157b2dfa3a2f8dc267cba6ff6fc550e2438a267ba61a238797aa37d72f1a0847281078e7c904b72cd24340588e9954b8232aaf882bfafd02d7666c2fe01b1330303b0ff20f4aea020caaf1e6bcb0df5400867bac316278a68f938f84a81d9a64fd17be9abfabc51df4350b06854d6ec023b80c8036611fdfa9b97e09f17d61fd3f28fe6ab1ba16a310f4b457b188c479e56fa477f86ddec27bc7f3b4d3140610c0ecf11072bccff8370b0eb539c73da997e86e0579e11edf25f41e281f827d3c71dc0ea8486faac522811d4b9fffae01d042c5b187e3119327555eb3770e6f1238b49c523bd1d856d4a1126af1afef55a7a31d815f9a2ec175f91938eb6888c980604fd480986168d72a99fea922ec42a7a88bdcd1dac35887227b39fa4afbb78ef0705edaf1319ea8ec06af657fc151f298015d39a2cf1f7a1215e8152759938f8598ae586eab5aaaced07885118bb100e6a7d045402719d29ec2cea1e5362e556de5ced27d66e0c43739fe6a85abb9a3c8847cbcc796e8ca97c59ab76bbac97211bc70e10fa202b94f1aa226a114ec3788bc729c76a7714083055c917a3590225375cfec19af5c371cd34032a0b1d04104ae70fb6a53a1d6bf5d3337f4cc37e3da4c0776e512db6955ee34bef49fe63bef278f653f0abd71bd17cefc05177ca219c8c1ca62972c98d82f02ef05ce58a9288bfaac3d28b6d80d003cc3d671299756a90db306cf3ba9e9d1b7513c5b3a56a7b3637ff7bf9f384ffab0b8f832d7a8aa48964449c8484109dfa38be386322fd7865e4ee6a1d28e40db5743776fba06bfd0445062c37487717146c8aaec76bb5d99e712d329344a52b75bb14b0d95cd25c23b7c46a52122f8f2951a2ada1555663535e636e3117dca3bd70a9b16e29ecf7d4441dea40f9f9b46860dda0de186d901463d66ee9b5ad28a1a0bf793eb73559bdca9cd23ac009af4185ef250c024386e52f956495721ae6eb1059741aa4c775a4a0952af62d5573c6eef5677ae95953c94cc7226ea2317ae9baeb3cf115eac156a0d0c9517a9b3c3c81e70526f38eb64d4d09de518d8e87520d496dc5c993db580c6c2280009a579e07a4048d175a45e28d1fe89d2f648339f40192e6f67a1f24dcc8f10c6e5317a2a1256de687eb716f15ae49c272ea3aae63dfe15df1c4f7b1569cfa17854e9b2106e10fa83a0fd3e03266a22d09f7d97bca41f94323023a7e3427e3847a36c12905681b79c574f87fe33f985e2beb29e2da68bcb2515b6f5cbfdbaa313b9ff1ae308323b58678e2b4381392dbad56ef29e1c5bebcbc8d8d8ef750ddf664bb676553fdb073330dc2c4cd59f5d908fa1938afcea13caffa9ce0eaea524d18b0595509822b222950272be15c4a3794d86591df8572761d3d62b1c0583d20258767e757e5ddd8a9ffb6d6ad60127e74c1b36068cc949f804a6f62e096a119d6775a6f3b740c50911ba6b1b703583e9c44740808e8667c72640803e37d53b58687412c520f278d3136f4335a501162a2c391ab5aff2cd5c280b939a6fd2e44615ad38d459d39092154adf84cbfb1e03967ba06af5190256ca3371e08c0552f90ed78dc6dd23ba9389148f7953401e14014e630d5dc3d6c4d7fbb01378ba5aa3b11092a8e4fb705d77b1795905112d34b78d8b2fdab864ee06fd81ed01458c0ee1d1f35a8e5c4f7141514c8cf9d122c45b40b2499e8b90b8d2aabaa0d616d333451f0dfe83e7d03d84fe2ea9228936c228ce9733d0acf2c15b8a9157efabd30c6ecfdc060d7956dae0f844c59ad8eca29abffbe518a08c6272407d08a2d2a2e0030450bebe975b7b9c1d048b17b3ec496abb445e7622467dc20ce3ae7198c5dbd77b0023387a4ce67aeb45006119631935120c6184c2f250a077b0ff9eec53b2333523b18d78dd28581dfe51a366893e2ac50a513d568b0466af7f3b757424993e965fad7f0ecdfb0260a2bd2780fa56b3d90b706e73d421f5fcb78f70b3cb557842337c2899e7eae611bd458432529eb045d04c8aefec1ebe3d0756d826ef524fc4e544c90f2a6b50ee3fc59736ffe4b9c597adddf545c1f8ab06213d5291189e07cda1dd686e519404f32873a786ae1a46c184594d2f1510a4fd47495e10f754e60376a6d866a64b151c53c6f0cce7815ef80cb977d8dc84e1357f645126264ab2ab9f52157c9285adecb4cad4c17739ebfacf3727964749542947d1e178850ccf9e2e365e305ab2ab0176b634e951152a07bd569eb38594bf0cef9c9082c1167e24297fadc5c369d96679b0d9868252ac8059b75d5d288c574a8b46a791483390de6a3024fad82caf76fdcdd0b1a02249888aff9e3c360f6d2715c22bee1e191641dd44fd252961b021e6551fe9218ed0bbc4fe0f0e4572d9689bd4dda05ec9878c7ad547ffafe25b2620d68b643d195ab09da382976c6eea9673d85112ae73ea6df814d3a0758d9f89a53e13b6f99606d0bf7d25208e747394f58668c4c3da261efcd34d85a7365d747910246956f07d6985b4074b1db0f4277301b096d2158c8ffd9c7d7f432781fc53298d4585ec4da73c48b33181e3d383c0d21a6a1a195c79a4824136d98cf785a2edc3e2b725d341b77aec766d361776039ed6a7df4e243fbd016783bff47f12d71488543b71df70a8a37fb8e6748c9eb5103ce3d22b8e7f6b12809a2dd65734f14f0f2faf9792a63466177512911a2e2f61448e11a64655431e5a1a95e927a800864fe6cbb8724829a2b98ada4c55104f72569e8410104a570459eb3dffbcdef278de0f4e3702032d4b6a9647ff7adadffb7e3f4ba67b0c73cb9b2e5b72a26d28568a57431bb299c202572412bf5c6c94374940e540e2276555ec212bc653b3a68d92b1f9d736e5771545615c1644cd9d6d906592d287cbca78961fd065fcbbf7da0b4bd3b9eaf8a8a2c3c406f0ea0c78d1c3ac63fd8e62edd60a4342d9408d50a7e0338c6222fecd75532032b9712840049645d98c361183f6b6ade89fae0ac43f584bb6e62e409c8dec0f39532d2901c7e82ca3635850a095f0c64b6d4747a01c17353611c654462808827f459f7efa360243dce5931623f1429e789bbaea363bb1eb6369585a0b4e41025d36dfb3b336589c54f73085eddc1457af28710eb0197ce5de5dca4a22476a5996f554de2f861271ab740ca8aa4f9ec6ddbecc720ea4f650b8e2809a8778ff941e2dd2ca3b994a145efb2b015708eb1e0ad201c396cc08d55850da912fc05465cf3367169e4494e65aa4cf0806307cb899bf1091a9d54ede36affc7fd1b0c4c013eaeb7fc484f4749ce27408637419b887e658041e84e6d82cc63bead0402ff1035c259a71e351b5845ddbb59a275ea7032736683d007556e8f21316474eff237b299484a4ea9c22abc12441f985d648cecc5448714afe68d3a7f747e3f077406d5ca94be8c1dbb07f284c4940e169957d8bd8a44e33af27576558ec331bba518b32a7fac05433a8bc2f0ebb0da7c5174a6189fe87368997d6fafe47764880fd1647c4f5437d91389af91f77121c5e5ea93885103a686e3c32912bdfad67c6262a16d5a5511bbbb5b28e0da8b290e65e1f5a562a8dc3a4e67491b87b173692efb329f31f7ab3e3895e54f119343e382064179fc8b00cd0cd4ee8fa4b2325f74a47ad6abcdc15230f7baf193a997ee986330565c13659cf428ade4f46d9ff687ecc\n      \n      \n        \n          \n          \n            请输入与 Nervld Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    ","categories":["Diary"],"tags":["Diary"]},{"title":"人机交互接口技术","url":"/2025/09/24/Course/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/","content":"大规模语言模型\n大模型出现之前（反复收集数据进行意图理解）\n大模型的知识不可靠（幻觉）\n大模型的通用语义理解比较重要\n\nGPT训练过程 🤖\n文字接龙-&gt;人类老师引导文字接龙的方向(RLHF)-&gt;模仿人类老师的喜好(用模拟人的模型去给模型打分)-&gt;向模拟的人类老师学习(通过训练奖惩模型提供实时反馈优化模型)\n\nprompt engineering：简单快速\n\nworkflow：成本大一点（需要多轮）\n\nfinetune适用场景：限定在一个企业、或者固定格式（让功能变快）\n\n\n什么是知识？🧀\n就是一幅图\n怎么去表征和计算\n\n什么是好的copilotAI的优势应用：\n\n人有两个系统：\n快系统（刷视频）❌\n慢系统（理性思维）✅\n\n\n交互设计界面：\n发现于一些细节的改进，比如给颜色增加标签red、green等\n\n\n通往AGI\nvLLM：空间语义也能变成token来进行计算\n\n\n\n失败案例：\n\nGPTS：人人都能定义的助手\n不可能通过几句话就让大模型具备复杂图才能表示的知识\n解决关键：交互式学习🔑\n\n\n\n大模型使用工具 🔨最早的：meta的Toolformer逐渐被Agent的概念覆盖构建Agent生态最好的只有Coze，没有更好的。语义计算（人）的不可控。\nAutoGPT：大模型在拆解人物理解任务的时候，很难和人类对齐\nRAG：\n\nRAG Fusion\nGraph-based RAG：存储关系而不是段落（更容易做总结）\nModular RAG\nAgentic RAG:用AI造AI\n\ni校对：查错别字 https://www.ijiaodui.com\n智能体交互式学习目前：\n\n由专家老师来注入知识给大模型\n\n但是：\n\n个性化的知识来自于个人\n要服务好人，这部分知识比例很高\n传统的推荐根据点击率这种简单的数据特征预测非常不准，因为不知道很多个性化数据（比如今天的工作内容什么的）\n\n因此需要有管家和多个agnet组成系统，管家提供的能力：\n\n和用户的交互（知识传递）\n拥有通用知识\n可以调用其他agent\nAI像一个龙卷风🌪️，卷到哪就把哪里的知识卷进去\n\n交互式学习：\n\n人在情境下根据行为模式产生决策\n情境只需要有足够传感器\n行为模式实际上就可以用贝叶斯表示核心研究问题：\n推理不确定性的度量\n交互成本和学习价值平衡\n贝叶斯因果建模\n用户心理模型\n多模态数据的语义表征\n\n\nGUI Agent的小场景PC自动化操作Copilot\n基于思维链建模的人机协同让AI经过一定的思考过程，再得出答案很多能力需要通过 RL 和 SFT 激发出来\n考虑：\n\n知识在哪\n知识怎么获取\n思维链只是简单的表示形式，更复杂的有图\n\n手势交互缺陷\n有模糊性\n难以记住\n太多难以记住\n太少表达有限\n认知复杂度越高，不同人的理解差异越大。\n\n\n\n好的交互\n新形态的ai硬件\n免唤醒（靠近、捂嘴）\n云端 Agent把记录📝给做好 &#x3D; 数据、用户\n\nGUI and Fitts LawMental Model打印机坏了，不同的人有不同的应对方法\n\n找教程？\n找官方维修店？\n找朋友？\n\n天生就有(Touch)通过使用学习(Keyboard)Metaphor(Windows)\nUser Interface Paradigm范式 paradigm\nFitts Law描述和预测点击任务的时间\n速度越快，光标移动越快\nuncertainty input\n文本输入原理与技术了解键盘布局的发展历程 —— QWERTY的由来QWERTY是为了打字机，将常用的字母分散在不同的位置，使得打印臂尽可能的远离彼此，减少碰撞和卡住的可能性。习惯的力量是不可忽略的（空间记忆、肌肉记忆、本体感觉）。\n理解文本输入问题的信息熵 —— 分组键盘增大按键的尺寸，让触摸变得更容易利用语言模型处理输入模糊性\n语言模型用户在智能键盘上平均每个单词可以减少77%输入。动态分组键盘，让用户用更少的移动距离来实现输入。\n触摸终端给文本输入带来的挑战机器理解用户移动的信息不充分问题\n\n贝叶斯定理\n\nP(A|B) &#x3D; P(B|A)·P(A) &#x2F; P(B)\n后验概率 &#x3D; 先验概率·似然函数 &#x2F; 边缘似然率\nB发生的情况下，A原因发生的概率，由A原因本身的概率，A发生的情况下B发生的估计概率除以B的边缘似然率。\n意图文字 -&gt; 屏幕触点 -&gt; 输出文字\n\n字符级文本纠错，预测盲人点击区域\n语音识别，免唤醒，默读识别，脑电输入文本等广义的脑电：瞳孔放大、肌肉电、gaze等\n信息无障碍universal design 考虑无障碍设计中国：2004年举办第一届中国信息无障碍论坛\n浙大软院+清华 做无障碍\nVirtual Paving 虚拟盲道（背包震动马达）、电子导盲狗、光引导\n盲人的听说读写\n\nlight right\ntouch 膜\ncv 按钮检测\n\n","categories":["Course"],"tags":["LLM","Agent","CHI"]},{"title":"信息艺术设计","url":"/2025/10/13/Course/%E4%BF%A1%E6%81%AF%E8%89%BA%E6%9C%AF%E8%AE%BE%E8%AE%A1/","content":"微软研究院关于\n致力于推动计算机科学领域的前沿技术发展，研究做到顶尖\n把最新研究成果快速转化到微软产品（全球蓝屏）\n下一代革命技术的研究和孵化，确保有未来（thinking week）\n《教育新语》\n市场上永恒的利益\n很多事情的来龙去脉\n\n管理\n不看量而看质\n给自己承诺：commitment\n\n创新流程\n研究院：战略规划\n产品组：按小时开发和创新（但是不一定采用研究院最新研究）\np0，产品定义（优先级最高，立刻做）\n每年需要评估上千万创意\n\n\n漏斗式：从很多开始，到一个结束\n\n从概念出发到达产品\n研究新的研究机会，并取得突破。\n寻找新的产品机会，找到产品的需求。\n提出解决方案并建立密切合作关系。\n在计划、实施、控制以及资源配置。\n项目团队是成功的关键。\n\n100个游戏1个成功，1000个游戏2个成功\n让对手活下来，但是半死不活（老师举例linux和微软）\n产品孵化\n找到恰当的合作伙伴\n\n说服产品经理考虑使用这项技术\n\n把需求从p1提到p0\n\n改进原型，使技术参数满足产品需求\n\n研究组一万次实验，有两次能成就行\n\n产品组：有一个bug就不能发布\n\n\n小结从概念到产品有巨大的鸿沟好论文实验结果和好产品是两码事产品开发是一个生态系统，技术只是一个因素（尽管很重要）团队是决定因素\n触觉交互设计\n特点：能同时进行感知和操作，“具身性”\n\n例子：\n\n3D建模笔：Phantom Omni 触觉交互设备\n通过真实感旋钮控制颜色等：Microsoft Surface Dial 交互控件\n\n人的思想和人身体分开：\n\n笛卡尔身心二元论\n“缸中之脑”人的思想和人身体不分开（具身性）：\n梅洛-庞蒂\n身体与心智结合认识世界\n\n盲人计算机：”人“的行为的差异性 -&gt; 找到设计对象与普通设计的区别 -&gt; 设计理念上的调整\n盲人数字生活的超级智能体学习场景（小学、初中、高中）生活场景（衣食住行、娱乐社交）工作场景（Google也有盲人写代码）\n三个尺寸 60x60，90x60，60x40\n高性能模组：\n\n电磁线圈+偏心轮（包含永磁铁）\n通过磁场方向控制上下\n显微镜装配\n\n\n人工智能技术人工智能的发展阶段\n基于符号逻辑的推理证明（1956～1976）\n基于人工规则的专家系统（1976～2006）\n大数据驱动的深度神经网络（2006~2022)\n大规模语料的应用（2023年3月～？）\n\n\n从认知革命到智能社会\n\n黄仁勋：\n\n未来两年，计算的世界将被彻底改写\n从Blackwell到Feynman的性能跃升\n生成式到 代理式（通过Issac GR00T N1赋予AI自主决策能力）与物理 AI（结合Omniverse数字孪生平台和Newton物理引擎）\nAI驱动的自动化革命\n劳动力市场的结构性革命：已有40%开始学习AI工程化技能，提示词工程与模型压缩\n能源与伦理瓶颈\n软件正在吞噬世界，但AI将吞噬软件\n\n技术驱动下的内容生产代际变革\nPGC 专业生成内容\nUGC 用户生成内容\nAIGC 人工智能合成媒体\nAGI 通用人工智能\n\nAI工具集网站 www.ai-bot.cn\n什么是研究？\n不是一份工作，而是一种爱好；更可能是终身的爱好。\n做好失败的准备了吗？\n创新思想，不要陈词滥调\n欢乐的英雄，不回避困难\n团结，发挥团队的优势\n敢于用失败去迎接胜利\n考虑5～10年后成为主流，而不是昙花一现\n\n我们的期望PeoplePapersPatentsPrototypesProduct transfersPR\n\n把自己的思想放到别人的脑袋里，推动精神文明的前进\n把别人的钞票收到自己的口袋里，促进物质文明的发展《麦田里的守望者》\n\nAIGC 三维空间投影&amp;光雕技巧实体空间有物体——跟物体结合实体空间无物体——通过射灯灯来实现视错觉质感和材质（通过后处理来更快做出效果）桌面投影（和实体的物体结合，传感器等，互动）3D光栅作品\n例子喷漆罐虚拟投影涂鸦\n\n和地面的互动\n实时流体模拟\nAI根据轮廓实时生成\n\n软件\nmadMapper（最专业）\ntouchDesigner（最综合）\nAE\n\nAI生成3D\ntripple3D\nRodin\n\n现在有了即梦之后，不需要提取轮廓，可以直接让AI生成视频\n升华\n数字艺术1950～1960年代：电子抽象艺术1960年是计算机艺术的起源时代，三维计算机艺术前驱，“3N”交互界面之父 ”图形学之父 \n绘图仪艺术作品《正弦人像》\n算法艺术家 Algorists\n1984年 AutoCAD发布\n2000～2015 Web2.0\n2017～2024 Web3.0\n作业工作记录视频1～1.5min小论文报告：动机 问题 用户 技术设计海报：A0纸队伍名：\n11月7日结课—12月10日左右交\n人居空间人居空间概述发展历程穴居 -&gt; 巢居（树屋） -&gt; 早期建筑的萌芽 -&gt; 原始聚落的形成 -&gt; 古代城市的发展 -&gt; 古代人居空间（规模小、功能单一）-&gt; 现代住宅的功能分区、设计理念、未来科技等\n理论与技术——以智能家居设计实践为例less is more少的色彩，简单的装饰（极简主义）\n分类：家居空间、办公空间、移动空间、公共空间\n传感器：电容：地板采集用户位置、步态、方向、速度、轨迹。嗅觉：传感器感知室内用户活动毫米波声波：检测空气湿度温度、二氧化碳、空气质量视觉：360° RGB相机，采集体态、动作、面部数据、热成像、深度相机空间坐标听觉： 多项麦克风阵列空间呻吟数据触觉传感器：传感坐垫、坐姿、睡眠状态\n创意灵感阿凡提餐厅。\n简化问题的复杂度：\n\n全身舞蹈太难，能不能局部\nxxx\nxx\nxxxxx\n乐队指挥\n\n通过运动捕捉学习音乐指挥\n餐厅动线设计故事\n红色房间更容易让人急躁\n《哥德尔 艾舍尔 巴赫：集异璧之大成》 GEB一条金色的纽带\n要有足够的信息消除歧义——减少幻觉和错觉\n","categories":["Course"],"tags":["CHI"]},{"title":"大麦","url":"/2025/10/22/Project/%E5%A4%A7%E9%BA%A6/","content":"大麦の疑问\n布隆过滤器检查可能存在，如果正好有个key不存在但是判断成了可能存在，不就每次穿透了吗？\n这个也许可以通过NULL值回写解决   布隆过滤器预热时间（整个数据库的所有key）会不会太久？\n\n\nJwt应该用长短登录，短的和redis过期同步，过期后需要长的来刷新并把用户数据存入redis。\n时钟回拨问题\n\n自我解惑\n基因法不应该把序列号覆盖掉，可以 尝试覆盖机器id的一部分，并且如果只用取模算法（不hash）的话，应该给序列号随机一个末尾时间（当前ms），可以缩短序列号，并加上时间戳偏移\n雪花算法保留符号位，是因为想要通过十进制的方式来展示id值\n给订单创建的幂等加一个状态，正在处理还是已经失败，服务器宕机重启的时候把正在处理变成已经失败。\n通过半消息和redis添加扣减记录来回溯没有发送成功给kafka的订单创建消息。\nthreadlocal是每个线程一个的map，里面存储的entry是threadlocal对象到value的映射，entry的key是弱引用，但value是强引用，所以即使把key（threadLocal对象）设为null，entry也不会消失\n由于线程池的线程复用，用完的threadlocal需要清理，另外由于threadlocal和线程绑定，需要用TTL来将父线程上下文传递给子线程。因此需要在进入子线程前把原来的上下文保存，然后执行子线程，执行完之后再恢复之前保存的。\nTTL负责：TransmittableThreadLocal值的自动跨线程传递\n装饰器负责：普通ThreadLocal（比如MDC里面的）的手动传递\n两者需要配合：TTL解决业务上下文，MDC装饰器解决日志上下文  public class IntegratedMdcTtlRunnable implements Runnable &#123;    private final Runnable delegate;    private final Map&lt;String, String&gt; mdcContext;        public IntegratedMdcTtlRunnable(Runnable runnable) &#123;        this.delegate = runnable;        this.mdcContext = MDC.getCopyOfContextMap(); // 捕获父线程的MDC        // TTL的传递由TtlRunnable.get()自动处理    &#125;        @Override    public void run() &#123;        Map&lt;String, String&gt; originalMdc = MDC.getCopyOfContextMap();        try &#123;            // 只设置MDC上下文（TTL上下文已由框架自动设置）            if (mdcContext != null) &#123;                MDC.setContextMap(mdcContext);            &#125;                        delegate.run(); // 此时业务和日志上下文都完整        &#125; finally &#123;            if (originalMdc != null) &#123;                MDC.setContextMap(originalMdc);            &#125;        &#125;    &#125;&#125;// 使用方式executor.execute(TtlRunnable.get(    new IntegratedMdcTtlRunnable(() -&gt; &#123;        // 这里既有TTL传递的业务上下文，也有MDC传递的日志上下文        log.info(&quot;处理业务&quot;); // 日志包含traceId        businessService.process(); // 业务代码能获取到TTL值    &#125;)));\n\n\n\n逻辑梳理目前的注册逻辑：\n\n会用uuid生成用户id\n会关联写入和phone 和 email的表\nUuid 经过 MOD 进行分库分表 （Apache ShardingSphere库）这里的MOD对不对呢？\n\n针对热门服务进行提前预热购票人数据。\n数据流动\n数据库操作方式这边应该没啥在可以优化的，传统的 线程池 +async &#x2F; await + 数据库连接池 已经够高性能了\n虽然数据库自己管理数据可能用了io多路复用，但是给用户的时候，还是得走网络或者内存拷贝。（或者作为服务器的内嵌进程，但是这样又不是很好扩展）\n数据从数据库里来，在redis里经受压力，最后消息队列同步给数据库\n\n分布式id在大麦网中，分布式id生成器对Mybatis-Plus中的雪花算法进行了改造优化，通过依靠redis来配置datacenterId 和 workerId，从而解决这个重复的问题，并且也集成了百度开源的UidGenerator，将依靠数据库自增的方式替换成了依靠redis自增，并且还用了cachedUidGenerator，来提前生产id\nMybatisPlus的生成datacenterId和wokerId的策略在k8s集群环境下，如果不是在同一个k8s环境中，mac地址有可能会重复，java服务进程id都为1，这就造成生成的id会可能重复。所以需要借助第三方来解决redis或zookeeper，因为redis比zookeeper更常用，最终决定用redis来生成datacenterId和workerId\n分库分表\n现在有一个虚拟分片路由映射表，可以知道每个虚拟分片的物理映射，迁移的时候先迁移后更新路由表。\n现在说是余票和座位修改了，后面即使订单生成出错也不好回滚，那能不能把记录发到消息队列里，超时的时候不仅仅简单丢掉，而是回滚一下呢？但是问题是有可能发送失败，此时只能依靠数据库重新刷入缓存解决了，因为数据库是和消息队列最终一致的。\n\n参数加解密不同平台的公私钥不同，都存在数据库中，比如小程序的、公众号的、客户端的。\n版本1 验证签名(默认)前端将业务参数和基础参数拼接用RSA的私钥生成签名，Gateway网关根据相应code参数查询出对应的公钥信息进行签名验证\n&#123;    &quot;code&quot;: &quot;1234&quot;,    &quot;businessBody&quot;: &quot;&#123;\\&quot;id\\&quot;:\\&quot;1111\\&quot;,\\&quot;sleepTime\\&quot;:10&#125;&quot;,    &quot;sign&quot;: &quot;JdTXuqMTCMGmM5zs7LoHwcEwFS5HQo/9bttao0GAAdoI/MpUpg7Eb5RN3Tmm4QT6FZVdJGVLqK48QKBAhJUlrBA8D14SJj7teMtPGboSxJ475+rGvgdycQbGKf7o40YBXwJGJeOG6xNJz913+Z8Zf/R9Sbd9gjF1QBXvSZy5i/sTNxhDOGydhLetInUcC/iMsqzoCk4e9MKltUSf4rQV4LQ0E171n93DtKLI4RZ9gPRzTBT7tPkpuPZ2GoJ5pJTQiNcjiDDYtHBPBeemrXtqumDblIJJuOBrcQk+1sYicQFy9ZQY1PAMoHjCTCPKNxUAULsodpXEj1TYJUl+q2jTwg==&quot;&#125;\n版本2 参数加密并签名\n请求头添加encrypt = v2，则将参数加密等级升级\n前端将业务参数通过RSA公钥加密，将未加密的业务参数和基础参数进行拼接用RSA私钥生成签名\nGateway网关将加密的业务参数用RSA私钥解密，然后将解密后的业务参数和基础参数进行拼接用RSA公钥进行验签\n接口返回时，Gateway用RSA的公钥将返回的参数进行加密，前端要进行解密&#123;    &quot;code&quot;: &quot;1234&quot;,    &quot;businessBody&quot;: &quot;SWwqEci1ci3Dog/iIKXirjirt+Va01RO2zlcBjPkpFBx1y2LPbKdgfLlGc+QnCgTXjbp/KkqFdqCcFBTJstdhy7+RNzxESBXKuuMlUwyXIPpNyIgLmSyu7Saoy2VbHw1Z2pXYTNdf7u3CL4MRuVjLszN6OY4qQozQAlp87sek2QLvh+wyi0csbXqJgvDDlh2LfpcFe7ycSxMDcTkYVOAqbHtXXzLI/I3W1KHcErHCZVuc+f6tk7Y4iBnR6MeFeqvOeziSBZVUBAQHlKr9Bm6fY1xHYx5NLavS8q/S4USwenntlG37J6Tb09D0+KahtAcguxLqTikbVxrcWpYv/tWRw==&quot;,    &quot;sign&quot;: &quot;EfxdpQB8GGWbQFNA1hBTnHhf4nWJerIsK+6NcuIptuzzooWgL+sFmGu9J9kG3hptiWRqkhW6DPDDRmfmUblvMuX9tC0jHoTnSeZBDkFi7+IJ+fdPg5iyi7+XHBCcR7pVilJgvjHXsDMjN3oaF1k4I56L5fYCfvcgSi6VQoGt+dB0kd4zWHWEGOu1c/TrowYCFaHElVq1fXPEd7dglbF2g4qHE8yrfELt6NXfO0K+P9elqB8NGnRcBQeM0d37+nQrCxOY5Mml2AKANs0UkLxZfrbqc95MjCWvDdRiQGGJnCIL1LZtMTsopgB2nGo8yMoqFVn4eE6G6wSFu1z1e5q4nQ==&quot;&#125;\n\n登录注销通过token和redis双重控制\n用户隐私信息脱敏通过AOP的方式用注解标注，在return值上做手脚\n用户数据加密通过sharding sphere的yaml文件配置\n创建订单订单首先在redis进行座位和票数扣减操作，紧接着发送消息给消息队列\n\n主要是CreateOrderConsumer类消费消息\n会检查消息延迟时间，超过5秒的消息会被丢弃\n正常消息会调用orderService.createMq()创建订单\n\n如果用户长时间未支付，有基于Redis的阻塞队列实现的延迟消息（分主题创建多个）：\n\n生产者通过DelayProduceQueue发送延迟消息\n消息先进入RDelayedQueue，等待延迟时间\n延迟时间到达后，消息自动转移 到RBlockingQueue（Redisson实现的）\n消费者通过DelayConsumerQueue监听RBlockingQueue获取消息\n\n前端会不断轮询查看是否订单创建完成，如果订单消息发送失败，订单的扣减库存操作会回滚。\n那如果后端服务挂了导致前端请求超时了呢，座位扣减了但是没有回滚？前端会轮询，所以\n定时任务\n订单相关定时任务 (damai-order-service)\n\n\nReconciliationTask: 每3分钟执行一次，执行对账任务\n@Scheduled(cron = &quot;0 0/3 * * * ? &quot;)public void reconciliationTask()\n\nPresentationOrderDataTask: 每天23:30执行，处理订单数据\n@Scheduled(cron = &quot;0 30 23 * * ?&quot;)public void executeTask()\n\n\n节目相关定时任务 (damai-program-service)\n\n\nPresentationProgramDataTask: 每天23:00执行，处理节目数据@Scheduled(cron = &quot;0 0 23 * * ?&quot;)public void executeTask()\n\n\n消息相关定时任务 (damai-customize-service)\n\n\nMessageRecordTask: 每分钟执行一次，执行对账任务\n@Scheduled(cron = &quot;0 0/1 * * * ? &quot;)public void reconciliationTask()\n\nPresentationMessageRecordTask: 每天23:00执行，删除所有消息记录数据\n@Scheduled(cron = &quot;0 0 23 * * ?&quot;)public void executeTask()\n\n这些定时任务主要用于：\n\n定期对账和数据处理\n清理过期数据\n维护系统数据一致性\n\n所有定时任务都使用了Spring的@Scheduled注解，并且都配置了cron表达式来定义执行时间。\n亮点组合模式验证逻辑组合模式构建验证逻辑树，通过抽象类，自动锁定某个业务需要的验证类，然后构建到树里。\n\n找到所有AbstractComposite.class的bean\n根据AbstractComposite::type值来聚合\n填入map\n执行时通过层序遍历\n\n","categories":["Project"],"tags":["java"]},{"title":"尝试一下同步","url":"/2025/11/23/Diary/2025-11-22%20%E5%B0%9D%E8%AF%95%E4%B8%80%E4%B8%8B%E5%90%8C%E6%AD%A5/","content":"辛苦啦！简单概括一下今天的情况吧~\n\n今天尝试同步一下obsidian仓库测试gitee手机上传(๑˃̵ᴗ˂̵)📱\n关于同步，最重要的是在第一次提交的时候就把gitignore给决定好(≧▽≦)&#x2F;♫\n","categories":["Diary"],"tags":["OpenDiary"]},{"title":"从Unity到UE的早期经验总结","url":"/2025/11/22/Tech/GAME/%E4%BB%8EUnity%E5%88%B0UE%E7%9A%84%E6%97%A9%E6%9C%9F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/","content":"背景最近重新拾起UE学习一段时间了，发现再次学习感悟确实比一开始多。并且逐渐发现了引擎的共通之处。故撰此文章来进行梳理，以引导后来的朋友，解我当初不能解之疑惑。\n毕竟当时我从Unity开始往UE转的时候，真的各种不习惯，也想着找一个别人总结的经验贴，但是当时感觉这些博客的比较太过公式化（也就是罗列各种API，仅仅是在UE C++中复刻Unity中的C#代码）。但忽略了我们真正的疑惑和需求。\n\n所以，我希望能从更加接近引擎设计逻辑的角度去探讨他们的不同，以及从一个具体的例子来指导我们逐步认识UE\n\n粗略对比编辑器文件组织结构Unity组织结构是一个Asset里面放置当前项目的所有资产和代码，当你打开一个unitypackage的时候，Unity会帮你直接导入到Asset文件夹，而UE这边则是导入Content文件夹。\n我们当然可以把Content当做Asset去使用，但是UE其实是提醒我们：\n\n我们自己的文件和资源也要创建一个文件夹，名字就是我们项目名称，这样我们的资源和Content资源就可以完全分开，我们需要什么，再去复制那一部分资源即可。\n\n场景视图以及游戏对象Unity的场景视图内的GameObject我们可以随意修改他们的父子关系，可是在UE里面并不容易，因此之前在Unity中使用的灵活的给不同物体创建脚本，甚至在游戏运行过程中在场景视图里面再去轻松的启用和关闭脚本、改变物体父子关系等等，就显得不那么适用。\n而这就引出了Unity和UE对待游戏对象很大的不同\n\nUnity开发者更喜欢组合的开发模式，把功能分散到各个脚本中，而脚本又分散到各个物体上，因为创造脚本很容易，并且每个脚本都能充分调用Unity的功能，再给自己加上各种组件。\n而UE开发者大部分时间用的是继承，比如创建一个个蓝图类去继承C++类，对于喜欢纯C++开发逻辑的我，比较倾向于将蓝图类比为Unity里面的Prefab，因为我的逻辑主要用C++实现，而创建蓝图，主要是为了将他们作为实例化对象，并且修改一些绑定的资源。\n\n引擎现有代码对于这一部分，我并没有做完整充分的调研，就个人感觉而言，Unity很多代码似乎集中在编辑器部分，这使得Unity的编辑器很稳定而且很好用。但UE的代码很多都集中在各种实用的功能上，比如一个自带的第三人称控制器，里面甚至包含了联机需要的代码。\n所以如果我们的目的单纯是制作游戏，那么当我们熟悉UE之后，做出一个功能完善的游戏是更加容易的。\n我们要写的代码正因为UE为我们添加了那么多功能和限定，让我们自己想要开始写功能的时候，最好的方案不是从零开始，而是先学习正确的使用方法，然后再编写代码。\n好在现在AI工具非常强大，并且虚幻官方的论坛也有很多问题的答案。因此我们要做的就是熟悉虚幻给我们的各种类。\n比如当我想要制作一个人物控制器的时候，涉及到的类就包括动画蓝图、角色控制器、SkeletalMesh，Montage、blend space等等，当然这些功能我们在学Unity的时候也是一点点学的，所以接受就好了，记住他们一般的作用流程。\n最关键的是当我们想要真正写自己的C++代码的时候，我们得在.h文件里面定义变量，通常是一些资产、一些组件的引用等等，这些名字我们要了解，可以从蓝图里面去找对应的名字。随后我们在.cpp文件中实例化这些组件，使用这些组件，并且可以通过方法改变这些组件的父子关系。\n\n不同于Unity中我们可以轻松的将组件和游戏对象区分开，这里我们要记得AActor是类似于GameObject的存在，但是Component也有可能是一个拥有自己Transform和独特功能的类似GameObject的存在，但是他们并不相同，比如AttachToComponent和AttachToActor，可以分别做到将一个对象转移到Component或者Actor的下面。（将一个物体转移到Component下？这在Unity是无法想象的）\n\n有时候蓝图里面的方法想要在C++使用并不方便，但是坚持用C++能让对象的引用关系和逻辑变得清晰。所以这里只能通过逐渐学习来熟悉API。\n以一个例子来详细对比\n比如说我们要实现一个第三人称射击游戏：\n\n在Unity中我们会创建一个空物体，然后给他绑定上碰撞体，动画器，再给他加一个子物体，显示出角色蒙皮，我们下载好动画资源并改为humanoid，就可以和角色适配上。但是在UE里，我们的动画需要经过重定向操作（相比还是挺耗时的）以更好的适配动画数据。\nUnity我们在动画器里面做出各种状态过渡，然后用C#代码给这些过渡条件提供值或者触发，而UE里面AnimInstance类就是动画器，我们创建一个C++代码继承它之后，它的成员就可以暴露给自己的蓝图子类，在子类里面编辑动画状态转移。\n为了实现武器拾取，我们都会在骨骼上放置插槽，当武器拾取之后，我们重新绑定父对象并设置Transform组件。只不过UE里面转移物体位置的函数，就自带可以填入插槽名称和Transform变化方式的参数。\n我们的武器需要生成子弹，这就需要创建一个子弹预制体以及子弹发射位置，在Unity中我们自然的完成这一动作，并用Instantiate进行实例化预制体，Instantiate是GameObject的方法，但是在UE中，我们用GetWorld()-&gt;SpawnActor&lt;&gt;()，并且我们如果要传入蓝图类，可以定义一个STSubclassOf&lt;AActor&gt;变量用于在编辑器里面传入蓝图类，然后我们把它当做预制体来生成。\n在Unity中我们可以用骨骼偏移来制作瞄准效果，UE中我们则使用Montage来在原本基础上再播放一个动画去覆盖原本动画。和Unity一样，动画文件里面可以放置通知，但是UE更多的是可以放置粒子特效什么的。Unity里面自动调用同名函数，而UE里面是在通知前面加上AnimNotify_作为前缀的方法，会自动调用。（UE是这样的，喜欢在各种地方加上前缀来标注，但是实际上用到的确实去除前缀后缀的属性、函数）\n其实UE用多了之后，会发现思路被UE的规则梳理过一遍之后，变得更清晰。当然在UE学习使用的过程中也会遇到各种各样意想不到的问题，这些在以后的文章中再分享~\n题外话用了UE的资产商店才知道优质的免费资源原来这么多，现在虽然虚幻商城全面转到了Fab上，但是免费资产赠送依然存在，并且据说周期缩短了，有时可以看到资产上面标注了对Unity的兼容性。\nFab商城链接：Fab\n","categories":["Tech"],"tags":["UE"]},{"title":"C++记忆知识点","url":"/2025/11/22/Tech/%E7%AE%97%E6%B3%95/C++%E8%AE%B0%E5%BF%86%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"不同类型的最大值在 &lt;limits.h&gt;里面c++就引入 &lt;climits&gt; \n\n\n\n类型\n最大值（科学计数法）\n\n\n\nint\n2e9\n\n\nunsigned int\n4e9\n\n\nlong long\n9e18\n\n\n字符串在 C++ 中，字符串操作非常常见。以下是一些常用的字符串操作方法和函数，主要是基于 std::string 类。\n1. 字符串初始化std::string str1 = &quot;Hello, World!&quot;;std::string str2(&quot;Hello, World!&quot;);std::string str3(10, &#x27;A&#x27;);  // &quot;AAAAAAAAAA&quot;\n2. 字符串连接std::string str1 = &quot;Hello, &quot;;std::string str2 = &quot;World!&quot;;std::string result = str1 + str2;  // &quot;Hello, World!&quot;str1 += str2;  // str1 变成 &quot;Hello, World!&quot;\n3. 获取字符串长度std::string str = &quot;Hello, World!&quot;;size_t len = str.length();  // len = 13\n4. 访问字符串中的字符std::string str = &quot;Hello&quot;;char ch = str[1];  // &#x27;e&#x27;str[1] = &#x27;a&#x27;;  // str 变成 &quot;Hallo&quot;\n5. 字符串比较std::string str1 = &quot;abc&quot;;std::string str2 = &quot;def&quot;;bool isEqual = (str1 == str2);  // falsebool isLess = (str1 &lt; str2);  // true, 因为 &quot;abc&quot; 小于 &quot;def&quot;\n6. 查找子字符串std::string str = &quot;Hello, World!&quot;;size_t pos = str.find(&quot;World&quot;);  // pos = 7if (pos != std::string::npos) &#123;    // &quot;World&quot; 被找到&#125;\n7. 获取子字符串std::string str = &quot;Hello, World!&quot;;std::string substr = str.substr(7, 5);  // &quot;World&quot;\n8. 替换子字符串std::string str = &quot;Hello, World!&quot;;str.replace(7, 5, &quot;C++&quot;);  // str 变成 &quot;Hello, C++!&quot;\n9. 插入子字符串std::string str = &quot;Hello!&quot;;str.insert(5, &quot;, World&quot;);  // str 变成 &quot;Hello, World!&quot;\n10. 删除子字符串std::string str = &quot;Hello, World!&quot;;str.erase(5, 7);  // str 变成 &quot;Hello&quot;\n11. 字符串转换为 C 风格字符串std::string str = &quot;Hello&quot;;const char* cstr = str.c_str();  // cstr 是 &quot;Hello&quot;\n12. 字符串拆分C++ 标准库中没有直接的字符串拆分函数，但可以通过 find 和 substr 来实现拆分操作：\n#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;std::vector&lt;std::string&gt; split(const std::string&amp; str, char delimiter) &#123;    std::vector&lt;std::string&gt; tokens;    std::string token;    std::istringstream tokenStream(str);    while (std::getline(tokenStream, token, delimiter)) &#123;        tokens.push_back(token);    &#125;    return tokens;&#125;// 使用示例std::string str = &quot;apple,banana,cherry&quot;;std::vector&lt;std::string&gt; fruits = split(str, &#x27;,&#x27;);  // [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]\n13. 去除字符串首尾空白字符#include &lt;algorithm&gt; #include &lt;cctype&gt;#include &lt;locale&gt;// 去除左侧空白std::string ltrim(const std::string &amp;s) &#123;    std::string result = s;    result.erase(result.begin(), std::find_if(result.begin(), result.end(), [](unsigned char ch) &#123;        return !std::isspace(ch);    &#125;));    return result;&#125;// 去除右侧空白std::string rtrim(const std::string &amp;s) &#123;    std::string result = s;    result.erase(std::find_if(result.rbegin(), result.rend(), [](unsigned char ch) &#123;        return !std::isspace(ch);    &#125;).base(), result.end());    return result;&#125;// 去除两侧空白std::string trim(const std::string &amp;s) &#123;    return ltrim(rtrim(s));&#125;\n14. 转换大小写#include &lt;algorithm&gt; #include &lt;string&gt;// 转换为小写std::transform(str.begin(), str.end(), str.begin(), ::tolower);// 转换为大写std::transform(str.begin(), str.end(), str.begin(), ::toupper);\n15. 判断字符串是否为空std::string str = &quot;&quot;;bool isEmpty = str.empty();  // true\n\nSTL库cmath&lt;cmath&gt; 是 C++ 标准库中的一个头文件，它提供了一系列用于数学运算的常用函数。以下是 &lt;cmath&gt; 中一些常用的函数：\n\n三角函数：\nsin(x): 返回角度 x 的正弦值。\ncos(x): 返回角度 x 的余弦值。\ntan(x): 返回角度 x 的正切值。\nasin(x): 返回 x 的反正弦值。\nacos(x): 返回 x 的反余弦值。\natan(x): 返回 x 的反正切值。\n\n\n指数和对数函数：\nexp(x): 返回 e 的 x 次方。\nlog(x): 返回 x 的自然对数。\nlog10(x): 返回 x 的以 10 为底的对数。\npow(x, y): 返回 x 的 y 次方。\nsqrt(x): 返回 x 的平方根。\n\n\n取整函数：\nceil(x): 向上取整。\nfloor(x): 向下取整。\nround(x): 四舍五入到最近的整数。\ntrunc(x): 截断小数部分，保留整数部分。\n\n\n其他常用函数：\nfabs(x): 返回 x 的绝对值。\nfmod(x, y): 返回 x 除以 y 的余数。\n\n\n\nclimits\nCHAR_BIT：定义了一个字节中位数的位数，通常是 8。\nSCHAR_MIN 和 SCHAR_MAX：分别定义了有符号字符类型 signed char 的最小值和最大值。\nUCHAR_MAX：定义了无符号字符类型 unsigned char 的最大值。\nCHAR_MIN 和 CHAR_MAX：分别定义了字符类型 char 的最小值和最大值，这取决于 char 是否被定义为有符号或无符号。\nMB_LEN_MAX：定义了多字节字符的最大字节数。\nSHRT_MIN 和 SHRT_MAX：分别定义了短整型 short 的最小值和最大值。\nUSHRT_MAX：定义了无符号短整型 unsigned short 的最大值。\nINT_MIN 和 INT_MAX：分别定义了整型 int 的最小值和最大值。\nUINT_MAX：定义了无符号整型 unsigned int 的最大值。\nLONG_MIN 和 LONG_MAX：分别定义了长整型 long 的最小值和最大值。\nULONG_MAX：定义了无符号长整型 unsigned long 的最大值。\nLLONG_MIN 和 LLONG_MAX：分别定义了长长整型 long long 的最小值和最大值（C++11 引入）。\nULLONG_MAX：定义了无符号长长整型 unsigned long long 的最大值（C++11 引入）。\nDBL_EPSILON：表示 double 类型能表示的最小正数，其值大约是 2.2204460492503131e-16。\nFLT_EPSILON：表示 float 类型能表示的最小正数，其值大约是 1.192092896e-7F。\n\nalgorithm求vector中最大的元素索引\nauto max_it = max_element(nums.begin(), nums.end());int max_idx = distance(nums.begin(), max_it);\n比较vector大小\n#include &lt;algorithm&gt;#include &lt;vector&gt;std::vector&lt;int&gt; vec1 = &#123;1, 2, 3&#125;;std::vector&lt;int&gt; vec2 = &#123;1, 2, 4&#125;;if (std::lexicographical_compare(vec1.begin(), vec1.end(), vec2.begin(), vec2.end()) ) &#123;    // vec1 在字典序上小于 vec2&#125;\n排序\n// 注意这里定义在class外bool compare(int a, int b) &#123;    return a &gt; b;&#125;class Solution &#123;\tvoid solve() &#123;\t\tsort(vec.begin(), vec.end(), compare);\t&#125;&#125;\n\n自定义类型的hashtemplate&lt;&gt;struct hash&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; &#123;    size_t operator()(const pair&lt;TreeNode*, TreeNode*&gt;&amp; p) const &#123;        // 计算哈希值        size_t hash1 = hash&lt;TreeNode*&gt;&#123;&#125;(p.first);        size_t hash2 = hash&lt;TreeNode*&gt;&#123;&#125;(p.second);        return hash1 ^ (hash2 &lt;&lt; 1); // 结合第一个和第二个哈希值以生成最终的哈希值    &#125;&#125;;\n\nPair可以通过下面的方式来解构元组\nauto [pr, node] = xxxx\nc++中元组是有 默认实现的 比较函数 的\nstring\n基本操作：\nlength() 或 size(): 返回字符串的长度。\nappend(str) 或 +: 将字符串追加到另一个字符串后面。\ninsert(pos, str): 在指定位置插入字符串。\nerase(pos, len): 删除指定位置开始的指定长度的字符。\nreplace(pos, len, str): 用另一个字符串替换部分字符串。\nsubstr(pos, len): 提取子字符串。\n\n\n访问字符：\nat(pos) 或 operator[]: 返回指定位置的字符。\nfront() 和 back(): 返回第一个和最后一个字符。\n\n\n查找和比较：\nfind(str, pos): 在字符串从pos位置从左向右查找子字符串。pos默认0\nrfind(str, pos): 从字符串的pos位置从末尾开始查找子字符串。pos默认末尾\ncompare(str): 比较两个字符串。\n\n\n转换：\nto_string(val): 将数值类型转换为字符串。\nstoi(), stof(), stod(), stol(), stoll(), stoul(), stoull(): 将字符串转换为数值类型。\nc_str(): 返回以 null 结尾的 C 字符串。\n\n\n\niostream可以结合文件，即#include &lt;fstream&gt;\n其中ofstream和ifstream分布代表输出，输入文件\n通过传入路径来构造类，is_open判断状态, close来关闭\n用 《  的方向来表示数据流的方向\n\n迭代器遍历方式\nfor(auto it = myUnorderedSet.begin(); it != myUnorderedSet.end(); ++it)&#123; \tstd::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;for (auto&amp; x : myUnorderedSet) &#123;\tstd::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;for (auto x : myUnorderedSet) &#123;\tstd::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;\n\n\n利用迭代器来用vector构造set\nset&lt;string&gt; deadendsOrVis(deadends.begin(),deadends.end());\n注意set会自动排序，按照数值，unordered_set则不会\npriority_queue 优先队列 &#x2F; heap 堆只需记住c++堆默认大顶堆，排序默认升序。 用的都是less比较函数即可\n创建优先队列的时候需要传入一个类（如果需要自定义，还会加上vector&lt;类&gt;, Comp或者greater&lt;类&gt;）也可以通过&#x3D;&#x3D;重载&lt;运算符&#x3D;&#x3D;的方式来实现自定义。\nc++ 默认大顶堆，填上greater函数可以改成小顶堆，a&gt;b是greater函数\n在 C++ 中，当你想要创建一个自定义的比较器（Comparator）来指定元素的比较规则时，你通常会重载括号运算符 operator()。这是因为在标准库中，像 priority_queue 这样的容器通常使用函数对象（Function Object）来进行比较操作。&#x3D;&#x3D;默认less大顶堆， &lt;   ,   降序&#x3D;&#x3D;&#x3D;&#x3D;用greater改为小顶堆， &gt; ,   升序&#x3D;&#x3D;\nstruct Comp &#123;    bool operator()(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)&#123;        // 自定义比较规则，比如按照第一个元素的大小进行比较        return a.first &lt; b.first;    &#125;&#125;;\n这样，当你使用 priority_queue 时，它将使用 Comp 中定义的比较规则来确定元素的顺序。\n排序时用sort不一样，那个要传入的是一个函数，可以用lambda或者外面写函数。对于函数 &lt; 表示升序\n大顶堆，就是每个节点都大于等于子节点的完全二叉树。但是使用的比较函数却是小于，因为要在父节点的值小于子节点的值时进行调整\nvector\nvector常见操作：\n初始化：创建vector并设置初始大小和默认值。\n访问元素：使用[]或at方法访问元素。\n添加元素：push_back、insert、emplace_back。\n删除元素：pop_back、erase、clear。\n获取大小和容量：size、capacity、empty。\n修改容量：reserve、shrink_to_fit。\n遍历元素：for循环、range-based for、迭代器。\n\n\n**resize**：\n增加大小：添加新元素，已有元素不变。\n减少大小：移除超出部分的元素，保留的元素不变。\n\n\nassign：不改变大小清空元素\n\nSTL\nset和map都是有序的，底层是红黑树\n只有前面加了unordered才是无序\n\n遍历方法map对于unordered_map，同样可以使用迭代器或范围循环进行遍历。下面是两种方法的示例：\n\n使用迭代器：\n#include &lt;iostream&gt;#include &lt;unordered_map&gt;int main() &#123;    std::unordered_map&lt;int, std::string&gt; myMap = &#123;&#123;1, &quot;One&quot;&#125;, &#123;2, &quot;Two&quot;&#125;, &#123;3, &quot;Three&quot;&#125;&#125;;        // 使用迭代器遍历unordered_map    for (auto it = myMap.begin(); it != myMap.end(); ++it) &#123;        std::cout &lt;&lt; &quot;Key: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;, Value: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;    &#125;        return 0;&#125;\n\n使用范围循环：\n#include &lt;iostream&gt;#include &lt;unordered_map&gt;int main() &#123;    std::unordered_map&lt;int, std::string&gt; myMap = &#123;&#123;1, &quot;One&quot;&#125;, &#123;2, &quot;Two&quot;&#125;, &#123;3, &quot;Three&quot;&#125;&#125;;        // 使用范围循环遍历unordered_map    for (const auto&amp; pair : myMap) &#123;        std::cout &lt;&lt; &quot;Key: &quot; &lt;&lt; pair.first &lt;&lt; &quot;, Value: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;    &#125;        return 0;&#125;\n\n无序映射(unordered_map)的遍历方式与有序映射(map)基本相同。\n输入输出按照格式读入和输出\n","categories":["Tech"],"tags":["algorithm"]},{"title":"PAT&CSP&蓝桥杯","url":"/2025/11/22/Tech/%E7%AE%97%E6%B3%95/PAT&CSP&%E8%93%9D%E6%A1%A5%E6%9D%AF/","content":"时间复杂度\n\n\n数据规模 (n)\n可接受的时间复杂度\n典型算法举例\n\n\n\nn≤10\nO(n!)\n全排列枚举\n\n\nn≤30\nO(2ⁿ)\n深度优先搜索 (DFS) 剪枝、状态压缩动态规划\n\n\nn≤500\nO(n³)\nFloyd算法、动态规划\n\n\nn≤5000\nO(n²)\n双重循环、动态规划、朴素Dijkstra\n\n\nn≤10^5\n**O(n log n)**​\n各种排序、堆、二叉搜索树、线段树、二分查找\n\n\nn≤10^6\nO(n) 或 **小常数O(n log n)**​\n单调队列、KMP、并查集（近似线性）\n\n\nn≤10^7\nO(n)\n双指针扫描、线性筛素数\n\n\nn≤10^9\nO(√n)\n判断质数\n\n\nn≤10^18\nO(log n)\n最大公约数、快速幂\n\n\n语法\n使用reverse函数传入的是迭代器的头尾，需要include &lt;algorithm&gt;\n使用istringstream要引入 &lt;sstream&gt;\n可以使用to_string方法来把数字转为字符串\n不能直接printf xxx.size()，需要强制转为int\nvector使用的是push_back\nmap插入要么是pair，要么直接用mp[key] &#x3D; value\n给一个没初始化的vector赋值使用 &#x3D; vector&lt;int&gt;(num,val)\n可以用({a,b})这种来构建结构体，或者作为隐式构造函数构造vector\nvector&lt;高级类型&gt; 高级类型必须有默认构造函数\nmax_element会返回第一个最大值的索引（如果有相同值）\n\n技巧\n空间换时间，可以开一个很大的数组，不用担心其中有些没有用到\n比较函数可以加一个flag来根据外界条件，做不同的比较逻辑\n模拟行为比模拟时间更好，把每个对象对外最重要的信息作为维护点即可\n通过记录一个点的所有前驱，可以记录所有最短路\ndfs可以记录路径然后在最后到达终点的时候处理这个路径的整个信息\n或者记录一个信息，不断更新\n\n\n二叉树递归的时候是一层一层来的，所以只需要在参数那里加个level就可以知道自己是第几层，改为2 x n + 1 和 2 x n + 2就变成了index 了\n两次DFS居然就能找到一个图的直径：第一次找到的是整个图直径的一个端点，第二次就能找到整个图的直径的另一个端点\n可以理解为先找到一个点，找到离他最远的所有点\n然后从离他最远的点里面找一个再去找，可能找到和最开始选的那个点近，但是离其他点都远的点\n1021 Deepest Root - PAT (Advanced Level) Practice (pintia.cn)\n\n\n\n常见错误\n判断浮点型是否相等需要借助 abs(差) &lt; 1e-5\n二分查找也可以考虑溢出的情况，另外注意我的统一写法是左闭右开\nvector的全局变量要用assign再初始化一下，必须两个参数，数量和初值\n一些常见类型错误的原因：\n段错误：数组越界，没有初始化\n运行时错误：没有初始化\n\n\n注意没有环路的图遍历是不需要还原vis状态的，可以想象成二叉树\n一定注意图的索引是不是从0开始\n内存超限：可以用一维代替二维\n时间超限：可以用数组代替vector\n奇奇怪怪？看看读入有没有问题\ncin不能获取空格，要用getline(cin,line);\n注意用getchar() 把上一行的\\n读掉\n\n\n\n骗分方法细心就是最好的骗分方法将问题简化，问题的逻辑和规模当成简化的来做先看【子任务】，这里说明了测试样例的分布可以用很笨的方法用打表的方式优化规模很大就用大数据结构存\n性能优化输入输出：\n// 关闭输入输出缓存，使效率提升 ios::sync_with_stdio(false); // 解除cin和cout的默认绑定，来降低IO的负担使效率提升 cin.tie(NULL); cout.tie(NULL);\n在输出时使用 \\n 来进行换行，避免使用 endl 也可提升输出效率。\n其他：\n\n使用const\n使用inline\n使用迭代器遍历，而不是指针\n\n蓝桥杯赛制OI，中途没法看到提交的结果策略：先暴力，有时间再根据数据范围来判断时间复杂度\n10^5 要优化到nlogn10^9 即使O(N)也会超时，所以o(1) 或者 o(根号)可能是数学题，可以打表找规律\n重点是 \n\ndfs, 状态压缩dp, dp, 二分, 各种sort, heap,　dijkstra，spfa，BFS，并查集，Kruskal\n\n顺序：基础算法(前缀(异或)和，二分，差分) &gt;  DP &gt; 搜索 &gt; 图论(最短路，最小生成树) &gt; 数据结构\n做题思路：先想一下暴力解法，然后看看能不能优化，如果不能想到优化，那就先写暴力\n暴力的方法：\n\nfor\nDFS,BFS\n打表找规律\n\n蓝桥杯中常见坑：\n\n必须写return 0\n一定要开long long 可以用 typedef long long ll;\n或者#define int long long, 然后signed main() {}\n\n\n需要优化iostream的速度或者用c标准库的\nios::sync_with_stdio(0);\ncin.tie(0); cout.tie(0);\n用\\n而不是endl\n不能混用，用上面的会导致scanf printf出现错误\n\n\n万能头#include&lt;bits&#x2F;stdc++.h&gt;\nINF 的值 0x3f3f3f3f\n\nGet-Content .\\in.txt | .\\test.exe &gt; out.txtdiff (Get-Content .\\out.txt) (Get-Content .\\in.txt)cmd 进入cmdchcp 65001 修改字符集为UTF-8type 输出文件内容.\\test.exe &lt; in.txt &gt; out.txt\n\n树上差分\n\n边权差分（用每个点来表示他与父亲相连的边的权）\n给起点和终点+1\n给两个点的最近公共祖先-2\n所有差分都完成之后，让每个点都加上子树和\n点权就是我们要拿到的边权结果\n\n\n点权差分\n\n单调队列和滑动窗口结合就可以维护一个窗口中的最值如果是二维的，先求每一行的结果（窗口大小为子矩阵长），再求每一列的结果（窗口大小是子矩阵高）\n状态压缩DP0表示不向下一格1表示向下一格\n\n\n","categories":["Tech"],"tags":["algorithm"]},{"title":"算法深度理解解析","url":"/2025/12/17/Tech/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%E8%A7%A3%E6%9E%90/","content":"数组双指针二分搜索看到「最大化最小值」或者「最小化最大值」就要想到 二分\n\n\n使用左开右闭\n如果mid偏大就要让right过来，mid偏小，让left过来\n要找最哪边的就把哪边固定住\n最后那个在相等时不变的量才可能是答案\n\n统一写法统一使用c++的lower_bound upper_bound的实现方式\nlower_bound 加上一个判断是不是相等，就可以当成是count\n采用[left, right)\n返回left\n\nlower_bound找到最小插入位置，即第一个大于等于target的位置upper_bound找到最后一个插入位置，即第一个大于target的位置\nint lower_bound(vector&lt;int&gt;&amp; nums, int target) &#123;\tint left = 0, right = nums.size();\twhile(left &lt; right)&#123;\t\tint mid = left + (right - left) / 2;\t\tif(nums[mid] &lt; target) &#123;\t\t\tleft = mid + 1;\t\t&#125; else &#123;\t\t\tright = mid;\t\t&#125;\t&#125;\treturn left;&#125;int upper_bound(vector&lt;int&gt;&amp; nums, int target) &#123;\tint left = 0, right = nums.size();\twhile(left &lt; right) &#123;\t\tint mid = left + (right - left) / 2;\t\tif (nums[mid] &lt;= target) &#123;\t\t\tleft = mid + 1;\t\t&#125; else &#123;\t\t\tright = mid;\t\t&#125;\t&#125;\treturn left;&#125;\n\n注意事项\n不需要数组是否为空的处理\nlower_bound的返回如果是0的话，说明数组找到了第一个数字\nupper_bound的返回如果是0的话，说明数组中所有数字都比target大\nlower&#x2F;upper_bound返回如果是size()的话，说明所有数字都比target小\n\n题目集\n可以看看 D:&#x2F;1work&#x2F;算法题\n1010 Radix - PAT (Advanced Level) Practice (pintia.cn)\n\n思路难题\n求一个有序数组中某一个数字的出现数量，可以通过right_bound - left_bound来实现\n二维矩阵中有行列的增减关系但是他们之间没关系，就找到一个角落，他的行进方向两个分别让值增加，减少，来调整方向找到值\n求x!末尾的0的个数，即里面有多少5，就有d&#x2F;5个加进去long res = 0;for (long d = x; d / 5 &gt; 0; d = d / 5) &#123;    res += d / 5;&#125;return res;\n山脉数组找封顶，找到中点处的两个值，确定峰顶所在方向，最后比一下left和left+1，看谁是顶峰\n1201.丑数 需要设计一个函数来求解某个数字以内有多少个丑数，需要用集合运算\n\n常数时间删除查找元素需要用hashset，为了可以对紧凑数组进行指定元素快速删除，就要用一个hashmap来存储每个元素对应的索引\n滑动窗口使用一个unordered_map来实现对元素数量的控制\n\n框架\n比较推荐 左闭右闭\n进入之后立即将当前right加入窗口，然后再++\n不符合条件且left＜right，缩减左边界后检查是否符合要求，left++\n\n一个while循环 right &lt; size进入之后先把right的单词取出然后更新一个while来让窗口符合要求\n思路难题\n438.找到异位词，即只有顺序不一样的序列\n需要记录一个need的map然后根据数量匹配找出valid的个数\n\n\n\n双指针可以是快慢指针，用于整理元素和删除元素\n可以是两边指针，用于夹逼目标，和随机整理元素\n\n链表的题通常需要注意两点：\n\n舍得用变量，千万别想着节省变量，否则容易被逻辑绕晕\nhead 有可能需要改动时，先增加一个 假head，返回的时候直接取 假head.next，这样就不需要为修改 head 增加一大堆逻辑了。\n拆分和合并操作不要舍不得\n\n矩阵的题\n\n从一维视角来看\n\n环形链表\n移动的时候判断fast和fast-&gt;next是不是存在\n通过快慢指针判断环\n到达一个地方的时候&#x3D;&#x3D;让其中一个回到起点&#x3D;&#x3D;速度再相同到下一次相遇就是环的位置\n判断相交链表，走完自己的路之后再去走对方的路，路途会不会重叠\n\n前缀和\n尽量使用0作为preSum开头的值，这样可以方便计算\n\n善用max来作为step函数削掉一些不合理的索引\n\n前缀和的作用可以是一个统计作用\n\n可以和hash结合来找到某一个值所在的索引\n\n区间信息快速获取-&gt; 前缀和\n\n区间快速操作（一个操作影响整个区间） -&gt; 差分数组\n\n\n动态规划自顶向下的动态规划，实际上就是有备忘录的遍历~所以有时候可以尝试遍历的写法框架，但是加上备忘录来剪枝。\n动态规划套路分析套路：\n\n集合（问题规模的表示方式，可能是状态压缩，状态机，坐标等等，他们虽然表面上是几个值，但是代表了一个集合）\n最后一步（看最后一步（当前要更新的状态）是由哪些集合导出的，不一定前一步就够，所以要不断划分）\n确定转移方程书写套路：\n确定一下dp数组的大小，根据含义来确定\n对dp数组进行初始化\n根据状态转移方程进行代码书写，也就是根据不同的条件来给出不同的转化\n如何压缩？\n可以通过将i和1进行&amp;操作使得某一维的大小只为2\n\n\n\n难题思路\n信封套娃问题：dp[i]表示长度为i的最长上升子序列末尾元素的最小值，所以我们取到的元素如果比最后一个小的话，优先接在dp的末尾，其他就放到他应该插入的left_bound位置\n打家劫舍问题：如果从左到右和从右到左的方式都差不多，而在条件最开始需要垫上几个，那最好就从右向左\n注意传入的参数是不是合理的，比如right是不是小于left\n\n善用数据结构有序的哈希表LRU 146题，多熟悉 239题，单调队列\n随机翻转矩阵\n矩阵太大，不能真的存储，其实也不需要那么多的值来存储\n使用hashmap存储那些被访问的，同时让他们关联一个存在矩阵末尾的值，这样就能只通过一次转换得到存在的值\n\n二叉树迭代器class BSTIterator &#123;    stack&lt;TreeNode*&gt; stk;public:    BSTIterator(TreeNode* root) &#123;        push_left_branch(root);    &#125;    void push_left_branch(TreeNode* root) &#123;        while(root)&#123;            stk.push(root);            root = root-&gt;left;        &#125;    &#125;    int cur() &#123;        return stk.top()-&gt;val;    &#125;    int next() &#123;        auto res_node = stk.top();        stk.pop();        push_left_branch(res_node-&gt;right);        return res_node-&gt;val;    &#125;    bool hasNext() &#123;        return !stk.empty();    &#125;&#125;;\n\n\n二叉树要么遍历，要么分治\n\n二叉树的还原通过前序中序，或者后序中序遍历结果可以确定⼀棵原始⼆叉树，但是通过前序后序遍历结果⽆法确定原始⼆叉树\n\n\n从前序遍历和中序遍历还原二叉树\n\n保证没有 重复元素\n需要快速分开左右子树然后使用build函数分别建立，之后合并\n使用一个hash表来快速找到中序遍历中的根，这样可以知道左右子树的位置关键是中序遍历，可以根据中序遍历来拆分子问题，需要给出每一次的根值和左右边界。知道根的位置就知道了左右子树的大小。\n\n\n从前后遍历还原二叉树\n\n需要指定左子树的根为先序遍历第二个\n\n\n\nBFS问题维护一个vis数组，一个dist数组（可选），一个深度变量\n一定记得在访问还有加入元素的时候维护他们\n\n\n使用BFS来寻找最短路径，思路就是让一堆点，或者一个点，向着各个方向都走一边，不需要去的点不要去\n\n二叉树的数学问题\n满二叉树（Full Binary Tree）：\n每个节点都有 0 或 2 个子节点。\n具有 h 层的满二叉树总共有 2^h - 1 个节点。\n在高度为 h 的满二叉树中，最后一层节点的数量总是等于 2^(h-1)\n\n\n完全二叉树（Complete Binary Tree）：\n在完全二叉树中，除了最后一层，其他层的节点都是满的，并且最后一层的节点都尽可能地靠左排列。\n具有 n 个节点的完全二叉树，其高度为 floor(log2(n)) 或 ceil(log2(n))。\n一个具有 n 个节点的完全二叉树的最大高度为 log2(n+1)-1。\n一棵具有 h 层的完全二叉树，至少有 2^(h-1) 个节点，至多有 2^h - 1 个节点。\n\n\n他们的关系：\n⼀棵完全⼆叉树的两棵⼦树，⾄少有⼀棵是满⼆叉树\n\n\n\n最近公共祖先LCA// 辅助函数，用于递归查找LCATreeNode* findLCA(TreeNode* root, TreeNode* p, TreeNode* q) &#123;    if (!root || root == p || root == q) &#123;        return root;    &#125;        TreeNode* left = findLCA(root-&gt;left, p, q);    TreeNode* right = findLCA(root-&gt;right, p, q);        if (left &amp;&amp; right) &#123;        return root;    &#125;    return left ? left : right;&#125;\n\n一般二叉树：\n\n从根节点开始递归遍历整棵树。\n当遇到当前节点等于其中一个目标节点时，返回当前节点。\n递归遍历左子树和右子树。\n如果左子树返回非空值，右子树返回非空值，则说明当前节点是最近公共祖先。\n如果左子树返回非空值，右子树返回空值，则左子树返回的节点是最近公共祖先。\n如果右子树返回非空值，左子树返回空值，则右子树返回的节点是最近公共祖先。\n如果左右子树均返回空值，则说明当前节点不是最近公共祖先，返回空值。\n\n二叉搜索树：\n\n找到第一个分叉点\n\n二叉搜索树操作原创 | 手把手刷二叉搜索树（第二期） (qq.com)美团面试官：你对二叉树后续遍历一无所知 (qq.com)\n前序遍历做的是就是考虑当前节点需要做什么，信息是从上往下传递的（比如通过参数传递引用）。从上往下传递举例：\n/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */  boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) &#123;      // base case      if (root == null) return true;      // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST      if (min != null &amp;&amp; root.val &lt;= min.val) return false;      if (max != null &amp;&amp; root.val &gt;= max.val) return false;      // 限定左子树的最大值是 root.val，右子树的最小值是 root.val      return isValidBST(root.left, min, root)           &amp;&amp; isValidBST(root.right, root, max);  &#125;\n\n而后序遍历可以将信息通过返回值传递，类似于分治\n这两个思维可以混合使用，从上往下传递信息，从下往上综合信息此外扩展思维↓，也可以加上，就是用全局变量来保存过程信息\n序列化和反序列化神级代码class Codec &#123;public:    // Encodes a tree to a single string.    string serialize(TreeNode* root) &#123;        if(root==nullptr)&#123;            return &quot;#&quot;;        &#125;        return to_string(root-&gt;val) + &#x27; &#x27; + serialize(root-&gt;left) + &#x27; &#x27; + serialize(root-&gt;right);    &#125;    TreeNode* mydeserialize(istringstream &amp;ss )&#123;        string tmp;        ss&gt;&gt;tmp;        if(tmp==&quot;#&quot;)&#123;            return nullptr;        &#125;        TreeNode* node = new TreeNode(stoi(tmp));        node-&gt;left = mydeserialize(ss);        node-&gt;right = mydeserialize(ss);        return node;    &#125;    // Decodes your encoded data to tree.    TreeNode* deserialize(string data) &#123;        istringstream ss(data);        return mydeserialize(ss);    &#125;&#125;;\n图图和树的区别是：树对于入度出度有明确限制，图可以有环\n遍历里面经典的traverse到底是什么traverse本身就是一个遍历\n你可以在他里面给他传递信息\n可以让他返回信息\n可以在他里面进行答案的保存与修改\n可以是二叉树的，可以是图\n\n回溯套路套路：\n\n可以把一些变量设置为全局的，比如路径，结果，一些需要记录的与目标和限制相关的东西\n在进入backtrack的时候需要判断一下是不是可以返回\n使用一个for循环来进入不同的子分支，记得在离开子分支的时候将之前的改动还原\n\n注意点：如果有信息需要传递给子分支而又跟子分支的后续循环有关，在后续循环过程中要不变，那就通过变量传递下去\n地图题例如海岛，迷宫这些可以用dfs或者bfs都可以目的是为了找到目的地\n而bfs可以同时找到最少需要的步数\n\n好题对经典算法扩展以求值未排序的数组中找元素位置，找元素某一侧【315】\n二叉树直径问题，对求深度问题进行扩展，每一次都求一下路径长度来max还有类似的，就是说求的东西可以是最终答案的子集，然后答案在中途维护\n第四题 寻找两个数组的中位数，这个需要有一个技巧，根据分出的中间的左右元素进行不同的操作，没啥框架，主要是二分\n","categories":["Tech"],"tags":["algorithm"]},{"title":"经典算法背诵","url":"/2025/12/17/Tech/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E8%83%8C%E8%AF%B5/","content":"数学试除法判断是不是质数稳定O(sqrt(n))\n\nbool is_prime(int n) &#123;\tif(n &lt; 2) return false;\t// 这里不用sqrt(n)是因为这个开销大\tfor(int i=2; i &lt;= n/i; i++) &#123;\t\tif(n % i == 0) return false;\t&#125;\treturn true;&#125;\n埃氏筛法bool is_prime[N] = &#123;true&#125;;void get_primes(int n) &#123;\tfor(int i=2; i &lt;= n; i++) &#123;\t\tif(is_prime[i]) &#123;\t\t\tprimes[cnt++] = i;\t\t\t// i是素数，那么i的倍数也都是\t\t\tfor(int j=i+i; j &lt;= n; j+=i) &#123;\t\t\t\tis_prime[j] = false;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n线性筛法（解决重复标记合数，更快）\n\nbool is_prime[N] = &#123;true&#125;;void get_primes(int n) &#123;\tfor(int i=2; i &lt;= n; i++) &#123;\t\tif(is_prime[i]) primes[cnt++] = i;\t\t// 从小到大遍历质数\t\tfor(int idx=0 ;primes[idx] &lt;= n/i; idx++) &#123;\t\t\tis_prime[primes[idx] * i] = false; // 将质数的i倍都删掉\t\t\tif( i % primes[idx] == 0) break; // i一定有最小质因子primes[idx]\t\t&#125;\t\t\t&#125;&#125;\n\n试除法分解质因数n中最多只包含一个大于sqrt(n)的质因子\n最好O(log(n)) ，最坏O(sqrt(n))\n\nvoid split_prime(int n) &#123;\t// 这里不用sqrt(n)是因为这个开销大\tfor(int i=2; i &lt;= n/i; i++) &#123;\t\tif(n % i == 0) &#123;\t\t\tint times = 0;\t\t\twhile(n % i == 0) &#123;\t\t\t\tn /= i;\t\t\t\ts ++;\t\t\t&#125;\t\t\tcout &lt;&lt; &quot;质因子&quot; &lt;&lt; i &lt;&lt; &quot;次数为&quot; &lt;&lt; s &lt;&lt; endl;\t\t&#125;\t&#125;\tif (n &gt; 1) cout &lt;&lt; &quot;质因子&quot; &lt;&lt; n &lt;&lt; &quot;次数为1&quot; &lt;&lt; endl;\treturn true;&#125;\n\n求因数个数和数值和一个数可以拆分为多个素数乘积，这些素数又可以选部分进行组合，每一个素数可以有0~k，即k+1种选择，总共就是他们相乘\n大数乘法【LeetCode43.字符串相乘 C++大数相乘 高精度乘法】 https://www.bilibili.com/video/BV1sK4y1t7o1/?share_source=copy_web&amp;vd_source=14e185a63eba25c1a3930fb174c86816\nstring big_mul(string a, string b) &#123;    int alen = a.length();    int blen = b.length();    int clen = alen + blen;    // 翻转AB    reverse(a.begin(),a.end());    reverse(b.begin(),b.end());    vector&lt;int&gt; c(clen,0);        for(int i=0;i&lt;alen;i++) &#123;        for(int j=0;j&lt;blen;j++) &#123;            c[i+j] += (a[i] - &#x27;0&#x27;) * (b[j] - &#x27;0&#x27;);        &#125;    &#125;    string res;    int carry = 0; // 表示低位给过来的进位    for(int i=0;i&lt;clen;i++) &#123;        carry += c[i];        res.push_back((carry % 10)+&#x27;0&#x27;);        carry /= 10;    &#125;    for(int i=res.length()-1;i&gt;=0;i--) &#123;        if(res[i] == &#x27;0&#x27;) &#123;            res.pop_back();        &#125;else&#123;            break;        &#125;    &#125;    reverse(res.begin(),res.end());    if(res.length() == 0) res = &#x27;0&#x27;;    return res;&#125;\n快速幂运算long long quickPow(long long base, long long exp, long long mod) &#123;    long long result = 1;    while (exp &gt; 0) &#123;        if (exp % 2 == 1) &#123;            result = (result * base) % mod;  // 如果指数是奇数，乘上当前的base        &#125;        base = (base * base) % mod;  // base自乘        exp /= 2;  // 指数减半    &#125;    return result;&#125;long long quickPow(long long base, long long exp) &#123;    long long result = 1;    while (exp &gt; 0) &#123;\t    if (exp % 2 == 1) &#123; //如果是奇数(二进制为1)就将当前底数乘到结果上\t\t    result = result * base;\t    &#125;\t    base = base * base;\t    exp /= 2;    &#125;    return result;&#125;long quickPow(long base, long exp) &#123;\tlong res = 1;\twhile (exp &gt; 0) &#123;\t\tif (exp % 2 == 1) &#123;\t\t\t// 是奇数就可以先乘一个base上去\t\t\tres*=base;\t\t&#125;\t\t// 否则就可以/2然后base**\t\tbase*=base; // 因为偶数必然变为奇数，肯定会乘到res上\t\texp/2;\t&#125;\treturn res;&#125;\n\nGCD求最大公约数，最小公倍数int gcd(int a, int b) &#123;\treturn b ? gcd(b,a%b) : a;&#125;// 辗转相除法求最大公约数int gcd(int a, int b) &#123;    while (b != 0) &#123;        int temp = b;        b = a % b;        a = temp;    &#125;    return a;&#125;// 最小公倍数是两数乘积除以最大公约数int lcm(int a, int b) &#123;    return (a / gcd(a, b)) * b;&#125;\n\n背包问题01背包for (int i = 0; i &lt; coins.size(); i++) &#123;      // 先遍历物品    for (int j = amount; j &gt;= coins[i]; j++) &#123; // 再遍历背包容量（倒序）        dp[j] += dp[j - coins[i]];             // 累加组合数    &#125;&#125;\n完全背包for (int i = 0; i &lt; coins.size(); i++) &#123;      // 先遍历物品    for (int j = coins[i]; j &lt;= amount; j++) &#123; // 再遍历背包容量（正序）        dp[j] += dp[j - coins[i]];             // 累加组合数    &#125;&#125;\n多重背包// 假设原始物品：数量 cnt，体积 v，价值 wint k = 1;while (k &lt;= cnt) &#123;\t// 拆出一个组合：k 个该物品\tnew_v = k * v;\tnew_w = k * w;\t// 将 (new_v, new_w) 当作 0-1 背包物品加入列表\titems.push_back(&#123;new_v, new_w&#125;);\tcnt -= k;\tk *= 2;&#125;if (cnt &gt; 0) &#123;\t// 剩下的部分\tnew_v = cnt * v;\tnew_w = cnt * w;\titems.push_back(&#123;new_v, new_w&#125;);&#125;\n排列背包for (int j = 0; j &lt;= target; j++) &#123;          // 先遍历背包容量\tfor (int i = 0; i &lt; nums.size(); i++) &#123;   // 再遍历物品\t\tif (j &gt;= nums[i]) dp[j] += dp[j - nums[i]]; // 累加排列数\t&#125;&#125;\nKMP算法// 构建next数组，这个next数组是表示从当前到开头的最长公共前后缀vector&lt;int&gt; buildNext(const string&amp; pattern) &#123;    int m = pattern.length();    vector&lt;int&gt; next(m, 0);    for (int i = 1, j = 0; i &lt; m; i++) &#123;        while (j &gt; 0 &amp;&amp; pattern[j] != pattern[i]) &#123;            j = next[j - 1]; // 要循环跳转到前一个的next值        &#125;        if (pattern[i] == pattern[j]) &#123;            j++; // j的值还代表了最长匹配前后缀长度        &#125;        next[i] = j;    &#125;    return next;&#125;// 构建nextval数组vector&lt;int&gt; buildNextVal(const string&amp; pattern) &#123;    int m = pattern.length();    vector&lt;int&gt; nextval(m, 0);    int i = 1, len = 0;    while (i &lt; m) &#123;        if (pattern[i] == pattern[len]) &#123;            len++;            nextval[i] = len;            i++;        &#125; else if (len &gt; 0) &#123;            len = nextval[len - 1];        &#125; else &#123;            nextval[i] = 0;            i++;        &#125;    &#125;    return nextval;&#125;// KMP搜索算法vector&lt;int&gt; kmp(const string&amp; text, const string&amp; pattern) &#123;    int n = text.length();    int m = pattern.length();    vector&lt;int&gt; next = buildNext(pattern);    vector&lt;int&gt; positions; // 存储匹配开始的位置    int j = 0; // 模式字符串的索引    for (int i = 0; i &lt; n; i++) &#123;        while (j &gt; 0 &amp;&amp; pattern[j] != text[i]) &#123;            j = next[j - 1];        &#125;        if (pattern[j] == text[i]) &#123;            j++;        &#125;        if (j == m) &#123;            positions.push_back(i - m + 1); // 匹配成功，记录位置            j = next[j - 1]; // 继续查找下一个匹配        &#125;    &#125;    return positions;&#125;\n排序归并排序public class MergeSort &#123;        public static void mergeSort(int[] arr) &#123;        if (arr == null || arr.length &lt; 2) return;        int[] temp = new int[arr.length];        sort(arr, 0, arr.length - 1, temp);    &#125;        private static void sort(int[] arr, int left, int right, int[] temp) &#123;        if (left &gt;= right) return;                int mid = left + (right - left) / 2;        sort(arr, left, mid, temp);        sort(arr, mid + 1, right, temp);        merge(arr, left, mid, right, temp);    &#125;        private static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123;        int i = left, j = mid + 1, k = 0;                // 合并两个有序数组        while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;            if (arr[i] &lt;= arr[j]) &#123;                temp[k++] = arr[i++];            &#125; else &#123;                temp[k++] = arr[j++];            &#125;        &#125;                // 复制剩余元素        while (i &lt;= mid) temp[k++] = arr[i++];        while (j &lt;= right) temp[k++] = arr[j++];                // 将临时数组复制回原数组        for (i = left, k = 0; i &lt;= right; i++, k++) &#123;            arr[i] = temp[k];        &#125;    &#125;&#125;\n快速排序public class QuickSort &#123;        public static void quickSort(int[] arr) &#123;        if (arr == null || arr.length &lt; 2) return;        sort(arr, 0, arr.length - 1);    &#125;        private static void sort(int[] arr, int left, int right) &#123;        if (left &gt;= right) return;                int pivot = arr[left];  // 选择第一个元素作为基准        int i = left, j = right;                while (i &lt; j) &#123;            // 从右往左找第一个小于基准的值            while (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;            // 从左往右找第一个大于基准的值            while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;            swap(arr, i, j);        &#125;        swap(arr, i, left); // i表示最后pivot的位置                sort(arr, left, i - 1);        sort(arr, i + 1, right);    &#125;&#125;\n快速选择算法quickSelect其实一般来说只需要O(nlogn)的优先队列算法就够用，实在过不了再用下面的O(n)算法\n\n   // O(n)时间选择出排序后的第K个元素，如果倒过来请给第N-K+1个元素    int quickSelect(vector&lt;int&gt;&amp; nums,int left, int right, int k) &#123;        if(left == right) return nums[left];        int partitionIdx = randomPartition(nums, left, right);        int curth = partitionIdx - left + 1;        if(curth == k)&#123;            return nums[partitionIdx];        &#125;else if (curth &gt; k) &#123;            return quickSelect(nums, left, partitionIdx-1, k);        &#125;else&#123;            return quickSelect(nums, partitionIdx+1, right, k-curth);        &#125;    &#125;    // 将最左边一个元素作为基准然后partition，返回基准位置    int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;        int x = nums[left];        int i = left, j = right;        while(i&lt;j) &#123;            while(i&lt;j &amp;&amp; nums[j] &gt;= x) j--;            while(i&lt;j &amp;&amp; nums[i] &lt;= x) i++;            swap(nums[i],nums[j]);        &#125;        swap(nums[i],nums[left]);        return i;    &#125;    int randomPartition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;        int i = rand() % (right - left + 1) + left;        swap(nums[i], nums[left]);        return partition(nums,left,right);    &#125;\npartition用for循环的版本（容易导致分布不均）：private static &lt;T&gt; int partition(T[] arr, int low, int high, Comparator&lt;T&gt; comparator) &#123;    T pivot = arr[high];  // 1. 选最后一个元素为基准（固定）    int i = low - 1;      // 2. 小元素边界指针（初始在low前面）        for (int j = low; j &lt; high; j++) &#123;  // 3. j遍历所有元素（除了基准）        if (comparator.compare(arr[j], pivot) &lt;= 0) &#123;  // 4. 当前元素 ≤ 基准            i++;                       // 小元素区域扩大            swap(arr, i, j);           // 把当前小元素放到小区域        &#125;    &#125;        swap(arr, i + 1, high);  // 5. 基准归位到小元素区域后面    return i + 1;            // 返回基准位置&#125;另一个类似的题目\n\n寻找两个正序数组的中位数public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;\tint m = nums1.length, n = nums2.length;\tint total = m + n;\tif (total % 2 == 1) &#123;\t\t// 奇数：找第 (total/2 + 1) 小的元素\t\treturn getKth(nums1, nums2, total / 2 + 1);\t&#125; else &#123;\t\t// 偶数：找第 (total/2) 小和第 (total/2 + 1) 小的平均数\treturn (getKth(nums1, nums2, total / 2) + getKth(nums1, nums2, total / 2 + 1)) / 2.0;\t&#125;&#125;// 在两个有序数组中找第k小的数private int getKth(int[] nums1, int[] nums2, int k) &#123;\t\tint m = nums1.length, n = nums2.length;\tint start1 = 0, start2 = 0; // 两个数组的起始位置\t\twhile (true) &#123;\t\t\t// 边界情况\t\t\tif (start1 == m) return nums2[start2 + k - 1]; // nums1用完\t\tif (start2 == n) return nums1[start1 + k - 1]; // nums2用完\t\tif (k == 1)  return Math.min(nums1[start1], nums2[start2]); // 只剩1个要找的\t\t\t// 正常情况\t\tint half = k / 2;\t\t\tint end1 = Math.min(start1 + half, m) - 1; // nums1的新位置\t\t\t\tint end2 = Math.min(start2 + half, n) - 1; // nums2的新位置  \t\t\tif (nums1[end1] &lt;= nums2[end2]) &#123;\t\t\t// 抛弃nums1的前半部分\t\t\tk -= (end1 - start1 + 1);\t\t\tstart1 = end1 + 1;\t\t&#125; else &#123;\t\t// 抛弃nums2的前半部分\t\t\tk -= (end2 - start2 + 1);\t\t\tstart2 = end2 + 1;\t\t&#125;\t&#125;&#125;\n\n二叉树平衡二叉树AVL#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Node &#123;    int key;    int height;    Node *left, *right, *parent;    Node(int key) : key(key), height(1), left(nullptr), right(nullptr), parent(nullptr) &#123;&#125;&#125;;int getHeight(Node *N) &#123;    if (N == nullptr)        return 0;    return N-&gt;height;&#125;int getBalance(Node *N) &#123;    if (N == nullptr)        return 0;    return getHeight(N-&gt;left) - getHeight(N-&gt;right);&#125;Node* rightRotate(Node *y) &#123;    Node *x = y-&gt;left;    Node *T2 = x-&gt;right;    x-&gt;right = y;    y-&gt;left = T2;    y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;    x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;    return x;&#125;Node* leftRotate(Node *x) &#123;    Node *y = x-&gt;right;    Node *T2 = y-&gt;left;    y-&gt;left = x;    x-&gt;right = T2;    x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;    y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;    return y;&#125;Node* insert(Node *node, int key) &#123;    if (node == nullptr)        return new Node(key);    if (key &lt; node-&gt;key)        node-&gt;left = insert(node-&gt;left, key);    else if (key &gt; node-&gt;key)        node-&gt;right = insert(node-&gt;right, key);    else        return node;    node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));    int balance = getBalance(node);    if (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key)        return rightRotate(node);    if (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key)        return leftRotate(node);    if (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123;        node-&gt;left = leftRotate(node-&gt;left);        return rightRotate(node);    &#125;    if (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123;        node-&gt;right = rightRotate(node-&gt;right);        return leftRotate(node);    &#125;    return node;&#125;void preOrder(Node *root) &#123;    if (root != nullptr) &#123;        cout &lt;&lt; root-&gt;key &lt;&lt; &quot; &quot;;        preOrder(root-&gt;left);        preOrder(root-&gt;right);    &#125;&#125;int main() &#123;    Node *root = nullptr;    root = insert(root, 10);    insert(root, 20);    insert(root, 30);    insert(root, 40);    insert(root, 50);    insert(root, 25);    cout &lt;&lt; &quot;Preorder traversal of the constructed AVL tree is:\\n&quot;;    preOrder(root);    return 0;&#125;\n\n先序遍历的非递归实现public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();    if (root == null) return result;        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    TreeNode node = root;        while (node != null || !stack.isEmpty()) &#123;        if (node != null) &#123;            result.add(node.val);     // 访问当前节点            stack.push(node);         // 压栈            node = node.left;         // 遍历左子树        &#125; else &#123;            node = stack.pop().right; // 回溯并转向右子树        &#125;    &#125;        return result;&#125;\n\n中序遍历public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    TreeNode current = root;        while (current != null || !stack.isEmpty()) &#123;        // 一直往左走，把所有左节点压栈        while (current != null) &#123;            stack.push(current);            current = current.left;        &#125;                // 弹出最左节点并访问        current = stack.pop();        result.add(current.val);                // 转向右子树        current = current.right;    &#125;        return result;&#125;\n\n\n图论算法并查集用于判断是否成环（最小生成树），用于求出连通分量个数，用于将某一部分剥离\n\nclass UnionFind&#123;    // 本题因为是按行列进行查找，优化可以直接采用哈希表public:    // 哈希表映射关系[key,parent]    unordered_map&lt;int,int&gt; parent;    // 总共有多少不连通的并查集    int count = 0;    // 并查集查找首领节点操作    int Find(int index)&#123;        if(!parent.count(index))&#123;            parent[index] = index;            count++;        &#125;        // 查找并查集的首领节点并优化        if(parent[index] != index)            parent[index] = Find(parent[index]);        return parent[index];    &#125;    // 并查集合并操作    void Uniod(int index1,int index2)&#123;        int parent1 = Find(index1);        int parent2 = Find(index2);        if(parent1 != parent2)&#123;            parent[parent1] = parent2;            count--;        &#125;    &#125;&#125;;class UnionFind &#123;private:    vector&lt;int&gt; parent;    int count;public:    UnionFind(int count) : count(count) &#123;        parent.resize(count);        for(int i=0;i&lt;count;i++) &#123;            parent[i] = i;        &#125;    &#125;;    void Union(int a, int b) &#123;        int pa = Find(a);        int pb = Find(b);        if(pa != pb) &#123;            parent[pa] = pb;            count--;        &#125;    &#125;    int Find(int x) &#123;        if(x!=parent[x]) &#123;            parent[x] = Find(parent[x]);        &#125;        return parent[x];    &#125;    int GetCount() &#123;        return count;    &#125;&#125;;\n连通分量分量指的是----一个图中的局部区域\n连通指的是图中任意两个点之间可以到达。\n强联通针对的是有向图\n弱连通针对的是将有向图看成无向图（无向图里叫连通分量，可以用UnionFind求）\n\nDAG的连通分量就叫强联通分量逆后序遍历是使用dfs遍历然后反过来，可以用作先子后父的拓扑排序\n无向图对于无向图，直接DFS就能遍历到一个连通分量的所有点，所以很简单\n有向图(强联通分量) Kosaraju 和 Tarjan经典算法先进行dfs，记录结束访问的顺序（出栈&#x2F;无后续节点可访问的顺序）然后将这个顺序倒序，将图转置然后根据现在的顺序进行dfs，每次得到一个强联通分量\n最小生成树Prim算法（稠密图）\n优先队列存储到所有点的权重（距离）\n取出权重最小的连接\n以新加入的点更新剩余点（不在最小生成树里）的权重并加入\n\nKruskal算法（稀疏图）\n排序所有边\n通过并查集Find，查看是否联通，决定是否Union\n\n回溯算法回溯就是按照树的方式进行穷举\n\n子集树（组合树）：排列树：\nN皇后#include &lt;iostream&gt;using namespace std;int n;int a[20];            // a[i] 表示第 i 行皇后所在的列bool flag_col[20];    // 列标记bool flag_diag1[40];  // 主对角线标记bool flag_diag2[40];  // 副对角线标记void dfs(int row) &#123;    if (row &gt; n) &#123;        // 找到一个解，输出        for (int i = 1; i &lt;= n; i++) &#123;            cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        return;    &#125;    // 尝试在当前行的每一列放置皇后    for (int col = 1; col &lt;= n; col++) &#123;        if (!flag_col[col] &amp;&amp; !flag_diag1[row + col] &amp;&amp; !flag_diag2[row - col + n]) &#123;            // 放置皇后            a[row] = col;            flag_col[col] = true;            flag_diag1[row + col] = true;            flag_diag2[row - col + n] = true;            dfs(row + 1); // 递归尝试下一行            // 回溯，恢复标记            flag_col[col] = false;            flag_diag1[row + col] = false;            flag_diag2[row - col + n] = false;        &#125;    &#125;&#125;\n\n差分约束图论学习-差分约束入门-CSDN博客\ntopo排序需要在 有向无环图(DAG)的条件下进行\n\n一种是用队列，每次找入度为0的点，加入并更新另一种用DFS：\n\n初始化：对于有向图中的每个顶点，初始化一个访问状态，初始为未访问。\n递归遍历：从任意未访问的顶点开始进行深度优先搜索（DFS）。\n对于当前访问的顶点 v，将其标记为已访问。\n递归遍历顶点 v 的所有邻接顶点，如果邻接顶点尚未访问，则继续递归遍历。\n\n\n顶点访问结束时加入结果：在递归回溯时，将当前顶点加入到结果列表中，即将当前顶点放在结果列表的最前面，因为当前顶点的所有邻接顶点已经被访问过了。\n重复步骤2和3，直到所有顶点都被访问过。比如两条路 A B C 和  A D C ，DFS 遍历顺序  A B C D 退出顺序 C B D A 拓扑顺序就是 ADBC\n\n以图判树用并查集检查\n无环 -&gt; 树\n+ 出入度满足 出度&lt;=2 除了根节点入度=1  -&gt; 二叉树\n\n自定义数据结构类考点手写堆// 堆化函数，调整堆的结构void heapify(vector&lt;int&gt;&amp; arr, int n, int i) &#123;    int largest = i;     // 初始化最大元素为根节点    int left = 2 * i + 1;  // 左子节点    int right = 2 * i + 2; // 右子节点    // 如果左子节点大于根节点    if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])        largest = left;    // 如果右子节点大于当前最大节点    if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])        largest = right;    // 如果最大元素不是根节点，交换并递归堆化    if (largest != i) &#123;        swap(arr[i], arr[largest]);        heapify(arr, n, largest);    &#125;&#125;// 堆排序函数void heapSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    // 构建最大堆    for (int i = n / 2 - 1; i &gt;= 0; i--)        heapify(arr, n, i);    // 一个个从堆中取出元素    for (int i = n - 1; i &gt; 0; i--) &#123;        swap(arr[0], arr[i]);  // 将当前最大元素移动到数组末尾        heapify(arr, i, 0);    // 重新调整堆    &#125;&#125;\n\n#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;functional&gt;#include &lt;exception&gt;using namespace std;  template&lt;typename T, typename Compare = std::less&lt;T&gt;&gt;class Heap &#123;private:    vector&lt;T&gt; data;    Compare compare;      void shift_up(int i) &#123;        while (i != 0 &amp;&amp; compare(data[(i-1)/2],data[i])) &#123;            std::swap(data[i], data[(i-1) / 2]);            i = (i-1)/2;        &#125;    &#125;    void shift_down(int i) &#123;        int childIndex;        while(i*2 + 1 &lt; data.size()) &#123;            childIndex = i*2 + 1;            if ( childIndex + 1 &lt; data.size() &amp;&amp; compare(data[childIndex], data[childIndex+1])) &#123;                childIndex++;            &#125;            // 如果父节点小于子节点，交换            if(compare(data[i], data[childIndex])) &#123;                std::swap(data[i], data[childIndex]);                i = childIndex;            &#125;else&#123;                break;            &#125;        &#125;    &#125;public:    void push(const T&amp; value) &#123;        data.push_back(value);        shift_up(data.size() -1);    &#125;    // 原地构造并插入元素    template &lt;typename... Args&gt;    void emplace(Args&amp;&amp;... args) &#123;        data.emplace_back(std::forward&lt;Args&gt;(args)...);        shift_up(data.size() - 1);    &#125;    T pop() &#123;        if (data.empty()) &#123;            __throw_out_of_range(&quot;Heap is Empty&quot;);        &#125;        T result = data[0];        data[0] = data.back();        data.pop_back();        shift_down(0);        return result;    &#125;    bool empty() const &#123;        return data.empty();    &#125;    const T&amp; top() const &#123;        if(data.empty()) &#123;            __throw_out_of_range(&quot;Heap is Empty&quot;);        &#125;        return data[0];    &#125;&#125;;\n\n\n\n字典树Trie用于解决前缀匹配问题\n\nstruct Trie &#123;\tunordered_map&lt;char, Trie*&gt; children;\tbool isEnd;\tstring val; // 如果结束了的话这里就是存储的对应的字符串结果&#125;\n\n\n线段树特殊的平衡二叉查找树，针对区间问题，大区间的问题必须可以由小区间获得（比如区间最大最小值，和）\n每个节点代表一个区间，a==b表示叶节点\n共有b-a+1个叶节点\n\n看动画，完全搞懂线段树，线段树的算法设计与实现，打ACM必会，动画版+讲师版_哔哩哔哩_bilibili\n优势：\n父节点表示的区间和子节点的关系：存储方式（用数组存）：数组的大小为 a[0] 到 a[b×2+2]，有些位置没有数据\nDijkstra算法实际上就是BFS变体\n使用优先队列实现的该算法可以用来求最大路径，即每次取出最大的，看能不能更新的更大\n\nclass State &#123;\tint id;\tdouble distFromStart;\t// 再写个构造函数&#125;\n\n使用优先队列来保存State按照  start开始到当前节点的已知最短路排序\n每次从队列里面取出最短的一个节点判断如果是end那就返回如果当前取出的dist&lt;dist数组记录的值    就continue（因为说明之前重复遍历了）\n遍历他的相邻节点，让他们经过当前节点转一下    如果转了之后更短了，那就更新dist数组并将节点新state加入队列\nclass State &#123;public:    int id;    double curMaxP;    State(int id, double curMaxP) : id(id), curMaxP(curMaxP) &#123;&#125;    bool operator&lt;(const State&amp; other) const &#123;        // 在这里定义比较规则，例如根据状态的某些属性进行比较        // 这里假设状态有一个整数属性 value，根据 value 的大小来比较        return curMaxP &lt; other.curMaxP;    &#125;&#125;;class Solution &#123;public:    double maxProbability(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;double&gt;&amp; succProb, int start_node, int end_node) &#123;        // 创建图        vector&lt;vector&lt;pair&lt;int,double&gt;&gt;&gt; graph(n);        for(int i=0;i&lt;edges.size();i++) &#123;            auto edge = edges[i];            int from = edge[0];            int to = edge[1];            double weight = succProb[i];            graph[from].push_back(&#123;to,weight&#125;);            graph[to].push_back(&#123;from,weight&#125;);        &#125;                // 需要按照state排序，每次找最大的        //! 这里的state类可以换成pair&lt;double,int&gt;，这样会默认按照double排序        priority_queue&lt;State&gt; pq;        vector&lt;double&gt; maxDist(n,-1);        State start(start_node, 1);        pq.push(start);        while(!pq.empty()) &#123;            auto [curId, curMaxP] = pq.top();            pq.pop();                        // 找到当前最大的            if(curId == end_node) return curMaxP;            // 如果比当前记录的还小那就算了            if(curMaxP &lt; maxDist[curId]) continue;            // 遍历他相邻节点            for(auto [nexId, weight]:graph[curId]) &#123;                double newDist = curMaxP*weight;                if(maxDist[nexId] &lt; newDist) &#123;                    // 更大                    maxDist[nexId] = newDist;                    pq.push(&#123;nexId, newDist&#125;);                &#125;            &#125;        &#125;        return 0;    &#125;&#125;;\n\n带路径记录的dijkstra1018 Public Bike Management - PAT (Advanced Level) Practice (pintia.cn)\nSPFA没有使用优先队列，就是普通队列，加上vis和负权边判断\n\nbool spfa(int vexNum, int source) &#123;    queue&lt;int&gt; q;    vector&lt;int&gt; cnt;    vector&lt;bool&gt; tag;    cnt.resize(vexNum);    tag.resize(vexNum);    for (int i = 0; i &lt; vexNum; i++) &#123;        dist[i] = INF;        cnt[i] = 0;        tag[i]  = false;    &#125;    q.push(source);    tag[source] = true;    dist[source] = 0;    path[source] = source + 1;    while (!q.empty()) &#123;        int u = q.front();        q.pop();        //! tag确保每个顶点只被加入到队列一次，以防止重复处理        tag[u] = false;        for (int i = 0; i &lt; adjacentList[u].size(); i++) &#123;            Edge edge = adjacentList[u][i];            if (dist[edge.to] &gt; dist[u] + edge.weight) &#123;                dist[edge.to] = dist[u] + edge.weight;                path[edge.to] = u + 1;                if (!tag[edge.to]) &#123;                    q.push(edge.to);                    tag[edge.to] = true;                    // 出现负权环则返回失败                    if (++cnt[edge.to] &gt; vexNum) &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;    &#125;    return true;&#125;\n\nFloydfor(int k=0;k&lt;n;k++) &#123;\tgraph[k][k] = 0;\tfor(int i=0;i&lt;n;i++) &#123;\t\tfor(int j=0;j&lt;n;j++) &#123;\t\t\tgraph[i][j] = min(graph[i][j], graph[i][k]+graph[k][j]);\t\t&#125;\t&#125;&#125;\n\n凸包问题\n先进行角排序\n然后维护一个栈\n栈内元素小于2，入栈\n新的点在栈顶两个点连线左侧，入栈\n否则弹栈\n\n\n\n\n\n","categories":["Tech"],"tags":["algorithm"]},{"url":"/2025/12/14/Tech/GAME/TA%E5%AD%A6%E4%B9%A0/","content":"相机渲染参数Depth 深度： 值小的先渲染Clear Flags： 选择的内容表示仅保留\n\n默认SkyBox，即清除天空盒以外的所有\nDepth Only 仅清除深度缓冲区，不清除颜色缓冲区，比如A摄像机先渲染，B摄像机设置了清除深度但是保留A的颜色，就会将B摄像机的内容直接叠加到A上\nDon’t Clear（不清除）：这种模式下，相机不清除任何颜色或深度缓存。结果是，每帧绘制在下一帧之上，造成涂片效果。\n\n渲染管线分为三大块\nCPU应用程序端 -&gt; GPU渲染管线 -&gt; Frame Buffer\n\nUnity内置渲染管线\nCPU应用程序剔除，排序，打包数据，绘制调用\n\n\n剔除分为 视椎体剔除（四棱锥求交），层级剔除（Layer），遮挡剔除（被静态物体遮挡的物体很容易剔除，但是不剔除被动态物体遮挡的）\n\n排序， 材质可以设置 render queue 的值，越小越先被渲染。 不透明物体默认2000，半透明物体默认3000，不透明队列(&lt;2500) 按摄像机距离从近到远，半透明队列(&gt;2500) 摄像机距离从远到近\n\n打包数据\n\n绘制调用 Draw Call\n\n\nGPU 渲染管线\n\n顶点Shader\n\n将顶点坐标转化到裁剪空间（任务）\n视椎体变化为2ω x 2ω x 1ω的立方体(CVV立方体)\n可以理解为只要把裁剪空间的深度1维度拍扁(通过硬件阶段)就得到2D图像了可以合起来成为MVP矩阵\n\n\n硬件操作阶段（图元装配及光栅化阶段）\n\n\n裁剪操作实际上发生在裁剪空间(CVV立方体)，裁剪空间是一个方便裁剪的空间，和之前的剔除阶段难度不一样\n背面剔除通过判断三角形顶点是不是逆时针顺时针来判断\n光栅化的过程是先将顶点进行插值绘线，然后再逐行扫描补全\n光栅化之后每个片元拥有的数据：其中深度值肯定有，UV坐标应该也是这个时候算好的\n\n\n片元Shader\n\n纹理技术\n小纹理映射到大区域，用纹理过滤器，如双线性，三线性插值\n大纹理映射到小区域，用Mipmap预先生成一些，而不是直接池化\n纹理寻址模式\n纹理压缩格式\n\n\n光照计算\n直接光照+间接光照\n直接光照的计算是可以每一帧进行的\nPhong &#x3D; Diffuse + Specular + ambient(环境光,Phong认为给个纯色即可,但是有更多方法可以模拟效果 IBL镜面&#x2F;球形光SH模拟漫反射环境光)\n\n\n\n\n\n\nShader效果拆解框架\n\n可以扩充SSS次表面散射\n\n\n\n\n\n\n输出合并\n\n处理遮挡关系，处理半透明混合（任务）\n整体过程 &#x3D; Alpha测试 模板测试 深度测试 混合\n帧缓冲区(Frame Buffer) 是关键 分为 Color Depth Stencil(模板) 这几种 buffer\n深度测试\n最开始深度都是1\n离摄像机越近越接近0\n可以通过 两个选项 来控制深度测试\nZWrite 深度写入： 关闭之后颜色正常但是不会留下深度值 \nZTest 深度测试：可以自定义通过深度测试的条件\n\n\n可以在片元着色器之前进行提前深度测试 Early-Z\n\n\n混合 Blending\n从后到前\n一般要关闭 ZWrite\n两种混合模式 alpha混合 和 柔和叠加(变亮)\n\n\n模板测试  开启并且手动设置哪些像素可以通过呈现的规则\n\n\n\n\n\nShader代码基础基本代码框架是\nShader &quot;名字&quot;&#123;\tProperties\t&#123;\t\t暴露变量\t&#125;\tSubShader\t&#123;\t\tPass  \t\t&#123;\t\t\tCGPROGRAM\t\t\t代码\t\t\tENDCG\t\t&#125;\t\t\t&#125;&#125;\n\n数值精度问题\n\n\n\n类型\n精度\n用途\n\n\n\nfloat\n32bit\n坐标点\n\n\nhalf\n16bit\nuv，大部分向量\n\n\nfixed\n8bit\n颜色\n\n\n剔除设置\n\n关闭剔除 Cull Off\n背面剔除 Cull Back\n正面剔除 Cull Front\n\n半透明渲染问题\n\n注意subshader中加入  Tags { “Queue”&#x3D;”Transparent” }\n注意对应Pass中关闭深度写入：  ZWrite Off\n设置混合模式  Blend SrcAlpha OneMinusSrcAlpha\n\nURP如果需要使用双通道，则：\n\nPass1加入：Tags { “LightMode”&#x3D;”SRPDefaultUnlit” }\nPass2加入：Tags { “LightMode”&#x3D;”UniversalForward” }\n\n贴图模式设置\n\n如果贴图突然哪里颜色不对，改成Ramp就不会超过采样边界了会直接截断\n\n常用变量计算\n\no.pos_world &#x3D; mul(unity_ObjectToWorld, v.vertex).xyz;\no.normal_world &#x3D; normalize(mul(float4(v.normal,0.0), unity_WorldToObject).xyz);\no.view_dir &#x3D; normalize(_WorldSpaceCameraPos.xyz - o.pos_world);\nhalf NdotV &#x3D; saturate(dot(normal_world, view_dir));\nhalf fresnel &#x3D; 1.0 - NdotV;\n\nMatcap效果世界法线转化到视角空间进行贴图采样即可\n\n顶点着色器实现藤蔓生长uv的v作为权重，减去growth值来控制alpha test 的clip\nsmoothstep用于控制权重集中的位置\n\n模板测试实现镜中世界镜子给出模板区域为1，想要透过的也得设置为1\n先渲染镜子但是没颜色，然后是镜子里的天空盒，而且天空盒必然通过深度测试(覆盖之前的外面物体)，然后是其他镜子世界的物体\n\n后处理技术将帧缓冲区中的颜色每个调动一下面片shader\n\nfresnel &#x3D; （1 - NdotV） 和 （power scale bias 处理）\n常用函数\nsphere mask\nhoudini和3Dmax可以用来烘焙顶点偏移动画其中展平成一条线的UV放在了UV2通道（其实是第三个通道）导入的贴图需要作出以下设置模型需要这样设置顶点偏移用的是RGBA Half，而法线方向用的是RGB 24bit\n法线图需要设置\n"},{"url":"/2025/12/14/Tech/GAME/Unity%E7%BB%8F%E9%AA%8C/","content":"如果出现找不到包错误，先下载package，还可以reimport all 然后再重新打开\n"}]